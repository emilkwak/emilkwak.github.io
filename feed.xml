<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>직장인을 위한 Python - Articles</title>
    <description>Python, Pandas를 Excel보다 사랑하는 직장인을 위한 블로그 </description>
    <link>
    https://emilkwak.github.io</link>
    
      
      <item>
        <title>Python 딕셔너리(dict) 키(key)를 변수로 만들기</title>
        
          <description>&lt;p&gt;Python의 딕셔너리(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;)는 C++나 Java의 그것보다 훨씬 유연하고 사용하기도 편합니다. 딕셔너리가 Python에서 자주 사용되는 이유이기도 하지요. 딕셔너리를 선언하고 정의하는 방법도 매우 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'var_a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;'var_b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;'var_c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 정의된 딕셔너리의 각 요소는 &lt;code class=&quot;highlighter-rouge&quot;&gt;d['var_a']&lt;/code&gt;와 같이 접근할 수 있지요.&lt;/p&gt;

&lt;p&gt;한편, 경우에 따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;print(d['var_a'])&lt;/code&gt;처럼 사용하는 것보다 &lt;code class=&quot;highlighter-rouge&quot;&gt;print(var_a)&lt;/code&gt;처럼 변수로 만들어 사용하는 것이 편할 때가 있지요. 작업중이던 변수들을 딕셔너리로 묶어 &lt;code class=&quot;highlighter-rouge&quot;&gt;pickle.dump()&lt;/code&gt;했다가 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;pickle.load()&lt;/code&gt;할 때 등이 대표적인 경우이겠죠.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s = &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 하면 딕셔너리의 각 요소를 변수로 만들 수 있습니다. 두 줄짜리 간단한 코드지만 원하는 바를 쉽게 달성하게 해 주죠. 위 코드를 간단히 살펴 봅시다. &lt;code class=&quot;highlighter-rouge&quot;&gt;d.items()&lt;/code&gt;는 딕셔너리를 키(key)와 값(value)의 쌍으로 나열시키고, 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;로 iteration합니다. 각 iteration에서 키를 변수명으로 삼아 변수에 값을 할당하는 구문을 문자열로 만들고 이 문자열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt;에 입력시킵니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt;은 말그대로 주어진 문자열을 Python 구문으로 여겨 실행시키지요.&lt;/p&gt;

&lt;p&gt;생각보다 간단하고 짧은 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 루프만으로 딕셔너리 각 요소의 변수로의 전환이 가능하지요?&lt;/p&gt;
</description>
        
        <pubDate>Mon, 15 Apr 2019 08:30:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/dict-to-var</link>
        <guid isPermaLink="true">https://emilkwak.github.io/dict-to-var</guid>
      </item>
      
    
      
      <item>
        <title>numpy의 argmax(), argmin() 그리고 argwhere() - 최대, 최소, 특정 값 찾기</title>
        
          <description>&lt;p&gt;학부 저학년 시절 첫 프로그래밍 언어를 접할 때, 정수형 array에서 최대 값의 위치를 찾기 위해 자연스럽게 loop을 사용했습니다. 아래처럼 말이죠.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;maximal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9999&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maximal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python에 익숙해 지면서 max()와 같은 기본 메서드를 손쉽고 자연스럽게 사용하게 되었습니다. 그리고 Python을 매력적으로 만들었던 inline for loop도 자유자재로 쓰게 되면서 아래처럼 컴팩트한 코드를 작성할 수 있게 되었죠.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;maximum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;numpy의 존재를 알게 되면서 큰 충격에 빠지지요. 이산수학 강의에서나 볼법한 수학 기호가 그대로 메서드로 구현되어 있더군요. inline for loop조차 구질구질해 보이게 만든 간결한 코드가 아래처럼 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;numpy의 argmax(), argmin()을 이용해 최대, 최소 값의 위치를 손쉽게 알 수 있습니다. argwhere()를 사용하면 특정 데이터의 위치를 매우 간편히 찾을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argwhere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바로 위 코드에서 볼 수 있듯이 argwhere()의 용법은 argmax(), argmin()과 다소 다르니 참고하세요.&lt;/p&gt;
</description>
        
        <pubDate>Sat, 13 Apr 2019 08:55:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/numpy-argmax-argmin-argwhere</link>
        <guid isPermaLink="true">https://emilkwak.github.io/numpy-argmax-argmin-argwhere</guid>
      </item>
      
    
      
      <item>
        <title>Pandas DataFrame(Series)의 문자열 contains(), startswith() 여러 값 적용하는 방법</title>
        
          <description>&lt;p&gt;Pandas Series는 강력한 문자열 처리 기능을 갖고 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Series.str.contains()&lt;/code&gt;는 특정 문자열을 포함하는 요소를 찾아 주고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Series.str.startswith()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Series.str.endswith()&lt;/code&gt;는 특정 문자열로 시작되거나 끝나는 요소를 찾아 줍니다. Series뿐 아니라 DataFrame의 각 열(column)에 대해서도 앞서 말한 기능을 쓸 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;DataFrame['COL1'].str.contains()&lt;/code&gt;처럼 쓰면 되지요. DataFrame에서 각 열은 Series이니 어찌 보면 당연한 얘기입니다.&lt;/p&gt;

&lt;p&gt;가끔 작업을 하다 보면 여러 문자열 중 하나라도 포함하는 경우, 또는 여러 문자열 중 하나로라도 시작하는(끝나는) 경우를 따져야 할 경우가 생깁니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;의 경우 ‘|‘(pipe)로 연결된(OR-ing) 문자열을 인자로 주면 되고, &lt;code class=&quot;highlighter-rouge&quot;&gt;startswith()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;endswith()&lt;/code&gt;의 경우 문자열의 tuple을 인자로 주면 됩니다. 이 방법을 알기 전까지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;df.COL1.apply(lambda x: any(i in x for i in ['this', 'that']))&lt;/code&gt;처럼 복잡한 코드 작성을 했었는데, 진작에 알았다면 이미 짠 많은 코드들이 간결하고 가독성 좋게 남아 있었겠지요.&lt;/p&gt;

&lt;p&gt;아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;에 ‘|‘로 연결된 문자열을 인자로 준 사례입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pandas as pd

names = ['jack', 'bob', 'watson', 'jake', 'mike', 'don', 'george', 'natasha', 'jill', 'ann', 'john', 'johnson']
ser = pd.Series(names)

ser[ser.str.contains('oh|son')]
# 2      watson
# 10       john
# 11    johnson
# dtype: object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;startswith()&lt;/code&gt;에 문자열의 tuple을 인자로 준 사례입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;endswith()&lt;/code&gt;에 대해서도 응용이 가능하지요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ser[ser.str.startswith(('j', 'a',))]
# 0        jack
# 3        jake
# 8        jill
# 9         ann
# 10       john
# 11    johnson
dtype: object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        
        <pubDate>Wed, 23 Jan 2019 08:30:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/pandas-contains-multiple</link>
        <guid isPermaLink="true">https://emilkwak.github.io/pandas-contains-multiple</guid>
      </item>
      
    
      
      <item>
        <title>Jekyll 블로그 사이트맵(sitemap) 설치(플러그인) 방법</title>
        
          <description>&lt;p&gt;개인 블로그(홈페이지 등)의 페이지들이 Google 검색에 잘 노출되게 하기 위해 Google Search Console에 사이트맵(sitemap)을 제출해 두면 좋습니다. 바닐라 Jekyll에는 없지만, Jekyll 플러그인을 설치하면 Jekyll 블로그의 사이트맵을 빌드 때마다 자동 생성(xml)할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 우선 사이트맵 플러그인을 설치합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install jekyll-sitemap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gemfile에 플러그인 설치 명령어를 추가해 둡니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano Gemfile

... (파일 하단에 아래와 같이 추가) ...
gem 'jekyll-sitemap'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설정 파일 플러그인 부분에 설치된 플러그인을 추가합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano _config.yml

... (파일 내 plugins 부분을 아래와 같이 편집 - 내용 추가) ...
plugins [..., jekyll-sitemap]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 Jekyll 빌드를 다시 한 후 서버 구동해 보시지요.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo bundle exec jekyll build --verbose
sudo bundle exec jekyll serve --host 0.0.0.0 --port 7070
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;your.jekyll.blog.url/sitemap.xml&lt;/code&gt;로 사이트맵 접속이 가능합니다. 이 주소를 Google Search Console에 사이트맵으로 제출하세요. 그러면 블로그 포스팅이 늘어날 때 Google이 보다 효율적으로 주소를 긁어 갈 수 있게 됩니다.&lt;/p&gt;
</description>
        
        <pubDate>Thu, 17 Jan 2019 07:30:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/jekyll-sitemap-plugin-installation</link>
        <guid isPermaLink="true">https://emilkwak.github.io/jekyll-sitemap-plugin-installation</guid>
      </item>
      
    
      
      <item>
        <title>메모리 덜 쓰고 Pandas DataFrame 병합을 빠르게 하는 방법(여러 개의 용량 큰 파일)</title>
        
          <description>&lt;p&gt;여러 개의 Excel 파일(또는 csv, pickle 등)로부터 같은 형태의 DataFrame을 차례로 읽어 들여 하나의 큰 DataFrame으로 합치려 한다고 합시다. 각 Excel 파일의 DataFrame의 컬럼 목록은 모두 같다고 하죠. 실제 사례를 상상해 보면, 날짜별, 시간별 로그 데이터가 파일 형태로 저장되어 있는 경우를 생각해 볼 수 있겠네요.&lt;/p&gt;

&lt;p&gt;가장 먼저 떠오르는 방법은 아래처럼 빈 DataFrame을 선언한 후 For Loop으로 각 파일을 읽어 붙이는 형태가 되겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 권장하지 않는 사례
import pandas as pd, os

base_dir = 'some/dir/path'

df_accum = pd.DataFrame() # 빈 DataFrame을 만듦.
for fname in os.listdir(base_dir):
    df_temp = pd.read_excel(os.path.join(base_dir, fname))
    df_accum = df_accum.append(df_temp) # 매 Loop에서 취해진 DataFrame을 앞서 정의한 빈 DataFrame에 붙임.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 이 방법은 다음의 두 가지 이유에서 좋지 않습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메모리를 많이 씁니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;df_accum&lt;/code&gt;은 점점 몸집이 커져 갑니다. Loop마다 커지는 몸집에 &lt;code class=&quot;highlighter-rouge&quot;&gt;df_temp&lt;/code&gt;를 붙이는 작업은 메모리 사용 차원에서 비효율적입니다.&lt;/li&gt;
  &lt;li&gt;속도가 느립니다. 크기가 큰 DataFrame을 &lt;code class=&quot;highlighter-rouge&quot;&gt;append()&lt;/code&gt;하는 것보다 작은 것을 하는 게 더 빠를 것입니다. 그런 차원에서 몸집이 커져 가는 &lt;code class=&quot;highlighter-rouge&quot;&gt;df_accum&lt;/code&gt;은 느린 속도의 주범입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실제로 pickle 기준으로 총 크기가 4.5GB인 데이터를 위와 같이 처리해 보면 속도가 매우 느린데다가 자칫하면 메모리 부족 오류(MemoryError)를 보게 되기도 합니다.(Windows 64-bit에 8GB RAM을 사용한다 하더라도 말이죠.)&lt;/p&gt;

&lt;p&gt;메모리 효율성 차원에서는 사실 뾰족한 답이 없습니다. 다만, ‘조금이라도 메모리를 덜 낭비’하면서 속도는 훨씬 빨리 할 수 있는 방법이 있습니다. 아래처럼 For Loop에서 등장하는 DataFrame을 list에 담아 두고 마지막에 list 통째로 &lt;code class=&quot;highlighter-rouge&quot;&gt;pd.concat()&lt;/code&gt;에 넣어 병합하는 방법입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 권장하는 사례
import pandas as pd, os

base_dir = 'some/dir/path'

list_of_df = [] # 빈 list를 만듦.
for fname in os.listdir(base_dir):
    df_temp = pd.read_excel(os.path.join(base_dir, fname))
    list_of_df.append(df_temp) # 매 Loop에서 취해진 DataFrame을 위의 list에 적재함.
df_accum = pd.concat(list_of_df) # list 속 DataFrame들을 일괄 병합함.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;말씀드린 것처럼 메모리 효율성을 급격하게 높일 수는 없겠지만, 속도 향상은 확실히 느낄 수 있을 것입니다.&lt;/p&gt;
</description>
        
        <pubDate>Tue, 15 Jan 2019 07:00:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/pandas-dataframe-concat-efficiently</link>
        <guid isPermaLink="true">https://emilkwak.github.io/pandas-dataframe-concat-efficiently</guid>
      </item>
      
    
      
      <item>
        <title>Python 리스트 인덱싱 &amp; 슬라이싱에 음의 값(마이너스) 사용해 보기</title>
        
          <description>&lt;p&gt;Python의 가장 큰 매력 중 하나가 리스트 인덱싱과 슬라이싱(list slicing and slicing)입니다. 각괄호와 콜론을 이용해서 리스트의 원소나 리스트의 일부를 쉽게 취할 수 있지요. C나 Java에서 배열 인덱싱, 슬라이싱했던 것과 비교하면 가독성과 간결성 측면에서 비교가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;인덱싱과 슬라이싱 외에도 Python의 리스트 연산(list operation)은 편리하기로 유명합니다. 여기에서는 음의 값(minus integer)을 이용한 리스트 인덱싱, 슬라이싱을 살펴 보겠습니다.&lt;/p&gt;

&lt;p&gt;우선 아래와 같이 실험용 리스트를 하나 만들어 보겠습니다. 0부터 9까지 10개의 정수로 채워진 리스트이죠. 리스트 속 각 인덱스 위치에는 인덱스와 동일한 정수 값이 들어 있는 형태입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i] = [i]&lt;/code&gt;인 형태 말이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = list(range(10))
print(a) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 리스트의 인덱스로 음의 값을 주면 어떻게 될까요? C를 생각하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[0]&lt;/code&gt;의 주소값 이전의 메모리 영역을 가리키게 되겠죠. Python에서는 그렇지 않습니다. 음의 값인 -n으로 인덱싱을 하면 뒤에서 n번째 요소를 가리키는 셈이 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(a[-1], a[-2]) # 9 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위를 보시면 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[-1]&lt;/code&gt;은 뒤에서 1번째 요소인 9를, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[-2]&lt;/code&gt;는 뒤에서 2번째 요소인 8을 가리키는 사실을 볼 수 있습니다.
이를 응용해 음의 값으로 슬라이싱을 할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(a[-2:]) # [8, 9]
print(a[:-2]) # [0, 1, 2, 3, 4, 5, 6, 7]
print(a[-3:-1]) # [7, 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위를 보건대, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[-2:]&lt;/code&gt;는 뒤에서 2번째 요소인 8부터 마지막 요소인 9까지를 슬라이싱하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[:-2]&lt;/code&gt;는 처음 요소부터 뒤에서 2번째 요소인 8까지 슬라이싱하되 8은 결과에 포함하지 않습니다. 원래 Python 리스트를 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[start:stop]&lt;/code&gt;과 같이 슬라이싱할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt; 위치에 해당하는 요소는 미포함(exclusive)하지요.&lt;/p&gt;

&lt;p&gt;리스트 슬라이싱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;stride&lt;/code&gt;에도 음의 값을 넣을 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;a[start:stop:stride]&lt;/code&gt;와 같이 슬라이싱할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;stride&lt;/code&gt;는 요소를 취하는 빈도를 나타냅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;stride&lt;/code&gt;가 2라면 하나 건너 하나를 취하겠죠. 아래처럼 말이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(a[::2]) # [0, 2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stride&lt;/code&gt;를 음의 값으로 하면 리스트가 역방향으로 슬라이싱됩니다. 이를 이용해 리스트의 역순 정렬(reverse sorting)도 할 수 있습니다. 아래의 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[-1:-3:-1]&lt;/code&gt;을 같이 보실까요? 뒤에서 1번째 요소인 9부터 뒤에서 3번째 요소인 7까지 슬리이싱하되 7은 결과에 포함하지 않겠지요? 따라서 결과가 &lt;code class=&quot;highlighter-rouge&quot;&gt;[9, 8]&lt;/code&gt;이 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(a[::-1]) # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
print(a[-1:-3:-1]) # [9, 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        
        <pubDate>Thu, 27 Sep 2018 09:00:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/python-list-indexing-slicing-using-minus-integer</link>
        <guid isPermaLink="true">https://emilkwak.github.io/python-list-indexing-slicing-using-minus-integer</guid>
      </item>
      
    
      
      <item>
        <title>Windows CLI로 구동한 웹 서버 멈춤 현상 해결 - 빠른 편집 모드 해제</title>
        
          <description>&lt;p&gt;Windows OS에서 웹 서버를 구동해야 할 일이 종종 있습니다. Microsoft IIS가 Windows의 대표적인 웹 서버 소프트웨어인데 Windows Server OS를 꼭 써야 할 상황이 아니고선 흔히 쓰이지 않지요. Apache가 가장 보편적으로 널리 쓰이는 웹 서버 소프트웨어가 아닐까 합니다. Windows에서도 WAMP를 통해 MySQL(MariaDB), PHP까지 통합하여 간편하게 설치해 사용하라 수 있습니다.&lt;/p&gt;

&lt;p&gt;Apache는 아무래도 무겁습니다. 요즘 핫한 Python과도 궁합이 아주 맞지는 않는 편이지요. Apache의 아성은 여전히 건재하지만 ‘그렇게나 제대로된 웹 서버가 아니더라도 성능은 적당하고 간편한 게 좋다’면 Apache 외에도 다른 선택지들이 많습니다.&lt;/p&gt;

&lt;p&gt;Python 사용자들에게 가장 친숙한 웹 프레임워크는 Django와 Flask입니다. 아직 Python 기반의 웹 서버를 이야기하고 있지 않습니다. Python 기반 웹 프레임워크에 관해 이야기하고 있습니다. Maximal한 기능을 제공하는 Django와 Minimalism을 추구하는 Flask, 둘 다 매력이 있는 웹 프레임워크이지요.&lt;/p&gt;

&lt;p&gt;Django와 Flask는 모두 웹 서버는 아니지만 개발용 간이 서버 기능을 포함하고 있기는 합니다. 프로덕션 차원에서는 쓰지 않기를 권장하고 있지만 서비스 트래픽이 과대하지 않다면 또는 접속량이 많지 않다면 임시적으로 프로덕션에 활용할 수도 있습니다. 좀 더 안정적인 웹 서비스를 위해서는 제대로 된 웹 서버 소프트웨어를 써야 하겠지요. Django, Flask와 궁합이 잘 맞는 웹 서버가 물론 있습니다.&lt;/p&gt;

&lt;p&gt;대표적인 Python 기반의 웹 서버로 Gunicorn, Waitress 등이 있습니다. Django, Flask와 같이 WSGI 사양을 준수하는 웹 프레임워크는 WSGI 사양을 준수하는 웹 서버와 최적의 호환성을 자랑합니다. Gunicorn과 Waitress는 WSGI 웹 서버이고 Django, Flask는 WSGI 웹 프레임워크이지요. 이들 간에 최고의 궁합을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;저는 Waitress를 좋아하는데 Linux뿐 아니라 Windows에서도 잘 구동되기 때문입니다. Gunicorn이 사실 더 유명하긴 하지만 UNIX/Linux 전용이라 Windows에서는 사용하기 힘들죠. 이런 차원에서 Waitress는 Python의 가장 큰 장점인 크로스 플랫폼 지원이 더 빛을 발하게 해 줍니다.&lt;/p&gt;

&lt;p&gt;서론이 좀 길었습니다만, Django 또는 Flask의 개발용 간이 서버를 이용하든, Gunicorn이나 Waitress 등의 웹 서버를 이용하든, Windows에서 서버 구동을 하기 위해서는 종종 CLI(DOS 창 또는 cmd라고 부르는)를 이용해야 할 상황이 많습니다. 다음과 같은 Python 파일을 CLI에서 실행하게 되겠죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 파일명: server.py
from waitress import serve
serve(wsgiapp, host='0.0.0.0', port=8080) # wsgiapp: WSGI 사양을 준수한 웹 어플리케이션이라 가정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Windows CLI에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;python server.py&lt;/code&gt;와 같이 위 Python 파일을 구동합니다. 웹 서버 프로세스가 생성되어 실행되고 Busy Running하게 되겠죠. 명령이 종료되지 않고 Listening 모드로 유지된 채 커서만 깜빡거리고 있겠지요. 당연한 상황입니다. 쉬운 말로 설명하려는 시도가 오히려 어색할 따름입니다.&lt;/p&gt;

&lt;p&gt;그런데 그런 경험 없나요? CLI 창(DOS 창)은 Listening 모드로 열러 있고 컴퓨터도 정상적으로 켜져 있으며 웹 서버 구동 직후 접속이 잘 됐었는데, 두어 시간 후 다시 접속하려면 접속되지 않는 현상을 겪은 적이 있나요? 원인을 찾을 수 없어 리부팅까지 해 봤는데도 여전히 반복되지요.&lt;/p&gt;

&lt;p&gt;혹시나 해서 CLI 창(Busy Running 중인)에 엔터 키를 입력해 보니, 접속 안될 때 서버로 들어 왔던 트래픽들이 버퍼링되어 있다가 한꺼번에 밀려 들어와 당황했던 적이 있나요? 몇 시간에 한 번씩 CLI 창에 엔터 키를 반복해서 눌러 줘야 하는 건가, 정녕 다른 방법은 없는 것인가 고민도 많이 했습니다.&lt;/p&gt;

&lt;p&gt;Linux Shell에 똑같이 하면 이런 문제가 없는데 왜 Windows에서만 문제일까 궁금합니다. 사실 명확한 원인은 모르겠습니다. 추측건대 CLI가 사용자 입력을 받기 위해 대기하는 가운데 키보드 입출력을 버퍼링하는 기능이 있어서 그것이 웹 서버의 출력까지 버퍼링 처리하고, 그 과정에서 무언가 꼬여서 먹통이 되는 게 아닐까 합니다. 이때 사용자로부터 엔터 키 입력이 들어오자 버퍼가 비워지고 먿었던 서버가 작동하게 되는 것이고요.&lt;/p&gt;

&lt;p&gt;원인은 잘 모르지만 어쨌든 해결책이 있어 소개드리겠습니다. Windows CLI 창이 열려 있다는 가정 하에(&lt;code class=&quot;highlighter-rouge&quot;&gt;Win+R&lt;/code&gt; 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd&lt;/code&gt; 실행) 다음과 같이 해 보시지요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows CLI 창의 타이틀 바 위에서 우클릭&lt;/li&gt;
  &lt;li&gt;컨텍스트 메뉴에서 ‘속성(P)’ 선택&lt;/li&gt;
  &lt;li&gt;‘편집 옵션’의 ‘빠른 편집 모드(Q)’ 체크박스 해제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 같이 처리한 후 CLI로 웹 서버를 구동하면 입출력 버퍼링이 원인으로 추측되는 웹 서버 멈춤 현상이 발생하지 않게 됩니다. 사실 이 글의 목적은 이 방법을 알려 드리기 위함입니다. 결론에 앞서 서론이 너무 길었는데요, 서론 없이 바로 방법을 설명했다면 어떤 상황에 대한 공감이 잘 되지 않았을 것 같습니다.&lt;/p&gt;
</description>
        
        <pubDate>Fri, 21 Sep 2018 09:00:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/making-windows-web-server-not-stopping</link>
        <guid isPermaLink="true">https://emilkwak.github.io/making-windows-web-server-not-stopping</guid>
      </item>
      
    
      
      <item>
        <title>Jekyll 정적 웹사이트 Github Pages에 호스팅하기</title>
        
          <description>&lt;ul&gt;
  &lt;li&gt;설치 환경: Ubuntu(Linux)&lt;/li&gt;
  &lt;li&gt;Ruby 개발환경 설치
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ruby-dev
gem install jekyll bundler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 테마 복제(clone)받기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/jekyller/jasper.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;이 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;jasper&lt;/code&gt;라는 디렉토리가 생겨 그 곳에 소스와 파일들이 내려받아짐.&lt;/li&gt;
      &lt;li&gt;Jekyll 테마는 &lt;a href=&quot;https://jekyllthemes.io/&quot;&gt;jekyllthemes.io&lt;/a&gt;와 같은 곳에서 찾아 내려받거나 Github에서 복제받을 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성 있는 Ruby 라이브러리 일괄 설치하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd jasper
sudo bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;복제받은 테마의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile.lock&lt;/code&gt; 파일을 참조해 의존성 있는 모든 Ruby 라이브러리를 일괄 설치함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 서버 로컬로 구동하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd jasper
sudo nano _config.yml
sudo bundle exec jekyll serve
sudo bundle exec jekyll serve --host 0.0.0.0 --port 7070
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;의 baseurl을 다음과 같이 변경(이렇게 해야 테마 assets(이미지, 레이아웃 등)가 적용되지 않거나 깨져 적용되는 현상을 없앨 수 있음.)
        &lt;blockquote&gt;
          &lt;p&gt;(변경 전) baseurl: /some/path/
(변경 후) baseurl: /&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;과 함께 실행하는 이유: &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle install&lt;/code&gt;로 설치한 루비 라이브러리들이 적용되는 환경에서 실행하기 위함.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--host&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--port&lt;/code&gt;: Jekyll 서버를 구동할 IP 주소와 포트를 명시함. 별도 명시하지 않을 경우 localhost:4000으로 구동함.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--host 0.0.0.0&lt;/code&gt;: 모든 IP 주소 허용 - 외부 공개를 위한 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(참고) 서버 실행 없이 Jekyll 빌드만 하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo bundle exec jekyll build --verbose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;를 하면 자동으로 빌드까지 한 후 서버를 구동함.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;는 서버 구동 없이 빌드만 시킴.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--verbose&lt;/code&gt;: 빌드 과정(빌드 대상, 결과) 로그를 표시하면서 빌드함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(참고) 미래 일자 포스트 빌드하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo bundle exec jekyll build --future
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--future&lt;/code&gt;: 원래는 미래 일자 포스트 빌드가 불가하나 &lt;code class=&quot;highlighter-rouge&quot;&gt;--future&lt;/code&gt; 부여 시 가능함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(참고) 특정 포트가 이미 점유된 경우, 점유한 프로세스 강제 종료하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo lsof -i :7070
sudo kill 582
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;7070 포트를 점유하고 있는 프로세스의 ID인 582를 확인해 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나의 Github Pages로 배포하기 위한 준비
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote -v
git remote set-url origin https://github.com/emilkwak/emilkwak.github.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote -v&lt;/code&gt;를 보면, 현재 복제받은 Github 주소를 그대로 origin으로 갖고 있음을 확인할 수 있음. 이대로 둔 채 &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;하게 되면 ‘남의 repository’로 배포하는 의도치 않은(?) 시도를 하게 됨.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote set-url&lt;/code&gt;을 통해 origin이 나의 Github Pages용 repository를 향하도록 함.&lt;/li&gt;
      &lt;li&gt;이 경우 emilkwak.github.io라는 repository가 나의 Github에 이미 생성되어 있음을 전제로 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(참고) origin을 유지한 채 origin2를 새로 만들어 사용하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote add orign2 https://github.com/emilkwak/emilkwak.github.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;나의 Github Pages로 동기화하기
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
git commit -m &quot;something to say&quot;
git push origin master
git push -f origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push -f&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;을 통한 동기화 없이 강제로 배포(overwrite)하게 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        
        <pubDate>Sat, 15 Sep 2018 09:00:00 +0900</pubDate>
        <link>
        https://emilkwak.github.io/jekyll-github-pages</link>
        <guid isPermaLink="true">https://emilkwak.github.io/jekyll-github-pages</guid>
      </item>
      
    
  </channel>
</rss>
