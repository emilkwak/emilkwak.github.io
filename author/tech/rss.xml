<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>emilkwak.github.io/</title>
   
   <link>https://emilkwak.github.io</link>
   <description>Python, Pandas를 Excel보다 사랑하는 직장인을 위한 블로그 </description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Python 별표(*) 문법(asterisk/star syntax), *args와 **kwargs</title>
	  <link>//python-star-asterisk-args-kwargs</link>
	  <author></author>
	  <pubDate>2019-07-06T07:00:00+09:00</pubDate>
	  <guid>//python-star-asterisk-args-kwargs</guid>
	  <description><![CDATA[
	     <p>Python에는 우리나라에서 흔히 별표라 부르는 asterisk(<code class="highlighter-rouge">*</code>)를 활용한 특이한 문법(syntax)가 있습니다. <code class="highlighter-rouge">*args</code>, <code class="highlighter-rouge">**kwargs</code>라고 해도 통합니다. C나 C++이 아닌 Python에서 <code class="highlighter-rouge">*</code>와 <code class="highlighter-rouge">**</code>를 문두에 사용하는 문법이 있다니 어색하긴 하지만, 용도를 제대로 알면 유용히 쓸 수 있습니다.</p>

<h3 id="메서드-정의-시-파라미터parameter로-쓰일-때">메서드 정의 시 파라미터(parameter)로 쓰일 때</h3>

<p>메서드 정의 시 파라미터(parameter)로 <code class="highlighter-rouge">*args</code>가 사용되면 그 메서드 내에서 <code class="highlighter-rouge">args</code>는 메서드 호출 시 투입된 아규먼트(argument)의 튜플(tuple)이 됩니다. 파라미터의 개수가 고정적이지 않은 메서드의 정의 시 사용됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">args_as_parameter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="n">args_as_parameter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'three'</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="c"># &lt;class 'tuple'&gt;</span>
<span class="c"># (1, '2', 'three', 4.0)</span>
</code></pre></div></div>

<p>메서드 정의 시 파라미터로 <code class="highlighter-rouge">**kwargs</code>가 사용되면 그 메서드 내에서 <code class="highlighter-rouge">kwargs</code>는 메서드 호출 시 투입된 아규먼트의 딕셔너리(dict)가 됩니다. 당연히 아규먼트는 key-value 형태여야 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kwargs_as_parameter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">kwargs_as_parameter</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s">'2'</span><span class="p">,</span> <span class="n">third</span><span class="o">=</span><span class="s">'three'</span><span class="p">,</span> <span class="n">fourth</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>
<span class="c"># &lt;class 'dict'&gt;</span>
<span class="c"># {'first': 1, 'second': '2', 'third': 'three', 'fourth': 4.0}</span>
</code></pre></div></div>

<h3 id="메서드-호출-시-아규먼트argument로-쓰일-때">메서드 호출 시 아규먼트(argument)로 쓰일 때</h3>

<p>메서드 호출 시 아규먼트로 <code class="highlighter-rouge">*args</code>를 투입한다 가정할 때, <code class="highlighter-rouge">args</code>는 튜플(또는 리스트, list 등)이어야 합니다. 따라서 앞서 정의한 메서드 <code class="highlighter-rouge">args_as_parameter()</code>를 다음과 같이 호출할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'three'</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="n">args_as_parameter</span><span class="p">(</span><span class="o">*</span><span class="n">input_tuple</span><span class="p">)</span>
</code></pre></div></div>

<p>메서드 호출 시 아규먼트로 <code class="highlighter-rouge">**kwargs</code>를 투입한다 가정할 때, <code class="highlighter-rouge">kwargs</code>는 딕셔너리이어야 합니다. 따라서 앞서 정의한 메서드 <code class="highlighter-rouge">kwargs_as_parameter()</code>를 다음과 같이 호출할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">'first'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'second'</span><span class="p">:</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'third'</span><span class="p">:</span> <span class="s">'three'</span><span class="p">,</span> <span class="s">'fourth'</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">}</span>
<span class="n">kwargs_as_parameter</span><span class="p">(</span><span class="o">**</span><span class="n">input_dict</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="args와-kwargs를-메서드-호출-아규먼트로-유용히-쓸-수-있는-용례"><code class="highlighter-rouge">*args</code>와 <code class="highlighter-rouge">**kwargs</code>를 메서드 호출 아규먼트로 유용히 쓸 수 있는 용례</h3>

<p><code class="highlighter-rouge">zip()</code>은 리스트들을 투입받아 묶어 주는 역할을 합니다. 이 기능을 이용해서 m * n 자료를 n * m 자료로 변환하는 데 쓰이기도 하지요. 행렬의 transpose 격입니다. m * n 자료를 <code class="highlighter-rouge">zip()</code>에 투입하려면 그 속에 들어 있는 길이 n의 리스트를 m번 투입해야 하겠지요. 한두 개라면 별일 아니지만 m이 커진다면 가독성과 생산성, 확정성이 매우 떨어지게 됩니다. 이때 <code class="highlighter-rouge">*args</code>를 활용할 수 있습니다. 아래처럼 말이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">two_col_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">))</span>
<span class="n">four_col_tuple1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">two_col_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">two_col_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c"># long way</span>
<span class="k">print</span><span class="p">(</span><span class="n">four_col_tuple1</span><span class="p">)</span>
<span class="c"># ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))</span>
<span class="n">four_col_tuple2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">two_col_tuple</span><span class="p">))</span> <span class="c"># short way</span>
<span class="k">print</span><span class="p">(</span><span class="n">four_col_tuple2</span><span class="p">)</span>
<span class="c"># ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cx_Oracle</code>의 <code class="highlighter-rouge">connect()</code>는 데이터베이스의 접속 정보(URL, 포트, 서비스명, ID, PW 등을 아규먼트로 받습니다. 이를 모두 <code class="highlighter-rouge">connect()</code> 메서드에 투입하려면 헷갈려 실수하기 쉽습니다. 물론 사용에 숙달되면 일도 아닐 정도로 쉽겠지만 ‘나만 잘 짜고 잘 읽고 잘 고치는 코드’가 능사는 아니지요. 이 경우 아규먼트를 딕셔너리로 정의한 후 그것을 <code class="highlighter-rouge">**kwargs</code> 형태로 <code class="highlighter-rouge">connect()</code> 메서드에 투입하는 방법이 있습니다. 향후 데이터베이스 접속 정보가 바뀌어 수정해야 할 때 딕셔너리 속 요소들을 쉽게 읽어 바꾸면 되니 관리하기 좋겠지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cx_Oracle</span>
<span class="c"># express way</span>
<span class="n">dsn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">makedsn</span><span class="p">(</span><span class="s">'localhost'</span><span class="p">,</span> <span class="mi">1521</span><span class="p">,</span> <span class="s">'orcl'</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">'sys'</span><span class="p">,</span> <span class="s">'orange'</span><span class="p">,</span> <span class="n">dsn</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">cx_Oracle</span><span class="o">.</span><span class="n">SYSDBA</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c"># tidy and readable way</span>
<span class="n">conn_conf</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">'user'</span><span class="p">:</span> <span class="s">'sys'</span><span class="p">,</span>
	<span class="s">'password'</span><span class="p">:</span> <span class="s">'orange'</span><span class="p">,</span>
	<span class="s">'dsn'</span><span class="p">:</span> <span class="n">dsn</span><span class="p">,</span>
	<span class="s">'mode'</span><span class="p">:</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">SYSDBA</span>
<span class="p">}</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="o">**</span><span class="n">conn_conf</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="참고자료">참고자료</h3>
<p>https://www.geeksforgeeks.org/args-kwargs-python/</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 정규표현식(regular expression) 그룹 이름 붙이기(named group)</title>
	  <link>//python-re-named-group</link>
	  <author></author>
	  <pubDate>2019-05-02T10:35:00+09:00</pubDate>
	  <guid>//python-re-named-group</guid>
	  <description><![CDATA[
	     <p>지금의 Python은 데이터 과학(data science)의 주류 언어로 각광받으면서, 프로그래밍 언어로서 황혼기를 누리고 있습니다. 데이터 과학의 러브콜을 받기 전 Python이 대중화가 될 수 있었던 이유는 강력한 문자열 처리에 있습니다. 사실 데이터 과학 분야에서도 Python의 문자열 처리 기능이 매우 유용하게 사용되지요. Tesorflow나 PyTorch 등 기계학습(machine learning) 및 인공지능(AI)라이브러리 또한 Python의 문자열 처리 기능 덕분에 더 빛을 발하지요.</p>

<p>Python에서도 문자열 처리 기능으로서 정규표현식(regular expression, regex)이 매우 유용히 사용됩니다. 사실 정규표현식은 Python만의 개념이 아니지요. 정규표현식 개념의 등장은 무려 1950년대로 거슬러 올라 갑니다. Python의 문자열 처리 기능의 강력함을 정규표현식만으로 설명할 수는 없는 노릇이지요. Python이 제공하는 특유의 문자열 처리 도구들과 특화된 라이브러리들과 정규표현식이 어우려져 사용될 때 비로소 막대한 시너지가 생깁니다.</p>

<p><code class="highlighter-rouge">startswith()</code>, <code class="highlighter-rouge">endswith()</code> 같은 기본 제공 모듈, <code class="highlighter-rouge">in</code>과 같은 키워드, <code class="highlighter-rouge">[:3]</code>, <code class="highlighter-rouge">[-5:]</code>와 같은 슬라이싱(slicing) 기능을 잘 활용하는 것도 물론 중요하겠지만, Python이 제공하는 정규표현식 라이브러리인 re를 능수능란히 다루는 능력 또한 중요합니다. 물론 정규표현식에 대한 기본 지식 또한 중요하겠지요.</p>

<p>여기에서는 Python의 re 라이브러리를 사용할 때 정규표현식 속 그룹에 이름을 붙여 이용하는 방법(named group)과 이름 붙여진 그룹에 직접 접근하는 방법을 살펴 보겠습니다. 이름 붙여진 그룹이라 함은, 별다른 뜻은 아니고, 정규표현식 속 일부가 되는 특정 패턴에 명시적인 이름을 붙였을 때를 말합니다.</p>

<p>가장 기본이 되는, 정규표현식 속 그룹에 이름을 붙이는 방법은 아래와 같습니다. <code class="highlighter-rouge">(?P&lt;NAME&gt;...)</code>은 괄호 속 패턴 부분에 NAME이라고 이름을 붙이는 방법입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">re</span>

<span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking'</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Michael speaking.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="c"># &lt;re.Match object; span=(7, 24), match=' Michael speaking'&gt;</span>
</code></pre></div></div>

<p>위 코드에서는 붙인 이름으로 <code class="highlighter-rouge">search()</code>로 찾은 패턴에 직접 접근하지 않습니다. 아래 코드처럼 하면 붙인 이름을 통해 패턴에 직접 접근할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># Michael</span>
</code></pre></div></div>

<p>하나의 정규표현식에 둘 이상의 그룹을 잡고 각각 다른 이름을 붙일 수 있습니다. 이처럼 그룹 수가 많아지면 <code class="highlighter-rouge">group(...)</code>을 여러번 쓰는 것보다, 이름과 패턴의 쌍들로 만들어진 딕셔너리(dictionary)를 <code class="highlighter-rouge">groupdict()</code>로 받아 와 쓰는 게 편리합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME1&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+and</span><span class="err">\</span><span class="s">s+(?P&lt;NAME2&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking'</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is John and Jane speaking.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">groupdict</span><span class="p">())</span>
<span class="c"># {'NAME1': 'John', 'NAME2': 'Jane'}</span>
</code></pre></div></div>

<p>한편 정규표현식에 이미 등장해 이름 붙여 놓은 그룹을 다시 참조해 같은 식에 재활용하는 방법도 있습니다. 이를 named group backreference라고 부릅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking</span><span class="err">\</span><span class="s">.</span><span class="err">\</span><span class="s">s+(?P=NAME)</span><span class="err">\</span><span class="s">s+is online</span><span class="err">\</span><span class="s">.'</span><span class="p">)</span>

<span class="n">result_a</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Michael speaking. Michael is online.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result_a</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># Michael</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result_a</span><span class="p">))</span>
<span class="c"># True</span>

<span class="n">result_b</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Thomas speaking. Paul is online.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result_b</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># AttributeError: 'NoneType' object has no attribute 'group'</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result_b</span><span class="p">))</span>
<span class="c"># False</span>
</code></pre></div></div>

<p>위 코드를 보면, <code class="highlighter-rouge">result_a</code>에서는 정규표현식의 앞부분에서 찾은 패턴 Michael이 뒤에 다시 등장하여 정상적으로 탐색(search)이 된 것을 알 수 있습니다. 반면 <code class="highlighter-rouge">result_b</code>에서는 앞부분 패턴은 Thomas지만 뒷부분 패턴은 Paul입니다. 앞뒤 패턴이 달라 탐색이 실패한 것이지요. 참고로, re 라이브러리의 정규표현식 결과를 <code class="highlighter-rouge">bool()</code>로 캐스팅(casting)하면, 패턴이 찾아진 경우 True, 아닌 경우 False를 반환합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 인라인 if절(inline if statement)에 elif 표현하기</title>
	  <link>//python-inline-if-statement-elif</link>
	  <author></author>
	  <pubDate>2019-04-24T20:30:00+09:00</pubDate>
	  <guid>//python-inline-if-statement-elif</guid>
	  <description><![CDATA[
	     <p>Python은 컴팩트한 코드를 지향하기 때문에 다양한 장치를 제공하는데, 그중 대표적인 것이 inline if절(statement)입니다. 사실 C/C++나 Java에도 비슷한 문법이 있습니다. 아주 새롭지는 않지요.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Python도 거의 유사한 문법을 제공합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Python의 inline if절이 가독성 면에서 뛰어나지요. 그리고 Python에서 손쉽게 사용되는 lambda 함수(function)와 어우러져 사용하면 용도가 더 빛나게 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Python inline if절을 쓰다보면 if와 else 말고 elif를 쓰는 방법은 없을까 싶지요. 물론 inline if절의 문법에 elif를 쓸 수 없게 되어 있습니다. 그럼에도 불구하고 사실상 elif를 구현하는 방법이 있습니다. 아래와 같은 inline이 아닌 if 조건 분기가 있다고 가정해 보지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'dog'</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">'woof'</span>
<span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'cat'</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">'meow'</span>
<span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'pig'</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">'oink'</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">'hello'</span>
</code></pre></div></div>

<p>어떻게 이것을 inline if절로 표현할 수 있을까요? inline if절의 else 부분에 괄호로 싸인 또 다른 inline if절을 사용하면 됩니다. 위 if 조건 분기는 아래처럼 바뀔 수 있겠지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="s">'bark'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'dog'</span> <span class="k">else</span> <span class="p">(</span><span class="s">'meow'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'cat'</span> <span class="k">else</span> <span class="p">(</span><span class="s">'oink'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'pig'</span> <span class="k">else</span> <span class="s">'hello'</span><span class="p">))</span>
</code></pre></div></div>

<p>한 줄이 좀 길긴 하지만, 어쨌든 inline은 맞지요? 물론 이런 경우에는 inline화 시키면서 가독성이 오히려 떨어집니다. 그럼에도 불구하고 가끔 이렇게 긴 inline if절이 유용할 때가 있지요. lambda 함수로 정의할 때가 그렇습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="s">'bark'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'dog'</span> <span class="k">else</span> <span class="p">(</span><span class="s">'meow'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'cat'</span> <span class="k">else</span> <span class="p">(</span><span class="s">'oink'</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">'pig'</span> <span class="k">else</span> <span class="s">'hello'</span><span class="p">))</span>
</code></pre></div></div>

<p>간혹 lambda 함수에 elif를 표현하고 싶은 때가 있죠? 그럴 때 활용하면 좋은 방법입니다. 실제로 위 lambda 함수에 각 인자를 입력하면 의도된 값이 잘 나옴을 볼 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="s">'dog'</span><span class="p">))</span>
<span class="c"># 'bark'</span>
<span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="s">'human'</span><span class="p">))</span>
<span class="c"># 'hello'</span>
</code></pre></div></div>

<p>앞서 보신 것처럼 elif의 표현이 많은 inline if절은 가독성이 떨어집니다. 이를 항상 유념하고 사용하면 보다 좋겠지요?</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 2차원 리스트(list)의 특정 열(column) 골라 취하기</title>
	  <link>//python-2d-list-certain-column</link>
	  <author></author>
	  <pubDate>2019-04-20T21:30:00+09:00</pubDate>
	  <guid>//python-2d-list-certain-column</guid>
	  <description><![CDATA[
	     <p>C나 C++에서 2차원 배열(2-dimension array) 개념을 많이 사용합니다. 배열을 요소(element)로 하는 배열로 표현을 하지요. Python에서도 리스트(list)를 2차원으로 사용하여 2차원 배열과 동일한 효과를 낼 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div></div>

<p>2차원 리스트의 특정 열(column)을 취해 처리해야 할 경우에는 어떻게 해야 할까요? Python의 기본 문법을 이용한 가장 C/C++적인 방법은 루프(loop)를 돌면서 처리하는 것이겠지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c"># [0, 2, 4, 6, 8]</span>
</code></pre></div></div>

<p>Python답게 inline for loop를 사용해 봅시다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c"># [0, 2, 4, 6, 8]</span>
</code></pre></div></div>

<p>zip을 이용한 방법도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c"># (0, 2, 4, 6, 8)</span>
</code></pre></div></div>

<p>Python 기본 문법을 넘어서 numpy나 pandas 등 라이브러리를 사용하면 훨씬 우아한 코드가 가능합니다. 아래는 numpy를 사용한 방법입니다. numpy의 array로 전환한 후 전치(transpose)시킨 후 인덱싱하는 순서입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c"># [0 2 4 6 8]</span>
</code></pre></div></div>

<p>위의 numpy 코드를 보면 매우 수학적인 느낌이 들지요? 2차원 리스트를 행렬로 인식한 후 전치행렬로 바꾼 다음 행 번호로 접근하는 과정이지요. 아래와 같이 pandas를 이용한 방법도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
<span class="c"># [0, 2, 4, 6, 8]</span>
</code></pre></div></div>

<p>pandas에 익숙한 분은 아시겠지만 pandas는 Excel 같은 스프레드시트 관점으로 접근합니다. 위 코드로는 정확히 느낌이 오지 않을 수 있지만, 2차원 리스트를 스프레드시트라 볼 수 있는 데이터프레임으로 바꾼 후 0열을 취하는 과정입니다.</p>

<p>Python 2차원 리스트의 특정 열만 골라서 선택적으로 취하는 방법을 알아 봤습니다. C/C++식 루프 돌리는 방법, inline for loop 이용한 방법, zip 이용한 방법, numpy나 pandas를 통한 방법이 있었습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Anaconda3(conda) 환경 Jupyter Notebook 오류(ImportError) 해결</title>
	  <link>//jupyter-notebook-conda-activate</link>
	  <author></author>
	  <pubDate>2019-04-18T07:30:00+09:00</pubDate>
	  <guid>//jupyter-notebook-conda-activate</guid>
	  <description><![CDATA[
	     <p>Anaconda3로 Python 환경을 설치하고 나서 Jupyter Notebook을 사용하려 할 때, 다음과 같은 오류가 발생할 때가 있습니다. Windows 운영체제라고 가정할 때(다른 OS도 크게 다를 것은 없습니다만), 명령 프롬프트(cmd)를 실행해 <code class="highlighter-rouge">C:\Users\ABC\Anaconda3\Scripts</code> 디렉토리로 이동한 후 <code class="highlighter-rouge">jupyter.exe notebook</code>을 실행하게 되지요.</p>

<blockquote>
  <p>ImportError: DLL load failed: 지정된 모듈을 찾을 수 없습니다.</p>
</blockquote>

<p>conda 환경이 아닌 맥락(context)으로 Anaconda3로 설치된 도구를 실행했기 때문으로 추정됩니다. 명확한 원인을 공식적으로 확인하지는 못했습니다. Scripts 디렉토리 내에 있는 다른 도구를 실행해도 유사한 오류가 발생하는 것을 보아 그렇게 추정이 됩니다.</p>

<p>Jupyter Notebook뿐 아니라, Python IDE인 Spyder 또한 실행되지 않습니다. Jupyter Notebook과는 다른 오류가 뜨지만 상황은 비슷해 보입니다. conda 환경에 맞춰 구성된 requirements와 dependencies가 충분히 해소되지 않기 때문이지요. 같은 <code class="highlighter-rouge">Scripts</code> 디렉토리에서 <code class="highlighter-rouge">spyder.exe</code>를 실행해 보시지요.</p>

<blockquote>
  <p>qtpy.PythonQtError: No Qt bindings could be found</p>
</blockquote>

<p>이를 해결하기 위한 여러가지 방법이 있겠지만, 가장 손쉬운 방법은 ‘conda 환경 갖추기’가 되겠습니다. 방법은 간단합니다. <code class="highlighter-rouge">Scripts</code> 디렉토리에서 <code class="highlighter-rouge">activate.bat</code>를 먼저 실행하면 됩니다. 아래처럼 하면 Jupyter Notebook이 위에서 살펴 본 오류 없이 잘 실행됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd C:\Users\ABC\Anaconda3\Scripts
activate.bat
jupyter.exe notebook
</code></pre></div></div>

<p><code class="highlighter-rouge">activate.bat</code>을 하고 나면 명령 프롬프트 커서 행의 좌측에 ‘(base)’라는 표시가 생깁니다. conda 환경, 정확히는 conda의 base 환경이 갖춰진 상태임을 뜻합니다. 이 상태에서는 Jupyter Notebook뿐 아니라 Spyder도 오류 없이 정상 구동됩니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 딕셔너리(dict) 키(key)를 변수로 만들기</title>
	  <link>//dict-to-var</link>
	  <author></author>
	  <pubDate>2019-04-15T08:30:00+09:00</pubDate>
	  <guid>//dict-to-var</guid>
	  <description><![CDATA[
	     <p>Python의 딕셔너리(<code class="highlighter-rouge">dict</code>)는 C++나 Java의 그것보다 훨씬 유연하고 사용하기도 편합니다. 딕셔너리가 Python에서 자주 사용되는 이유이기도 하지요. 딕셔너리를 선언하고 정의하는 방법도 매우 간단합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">'var_a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="s">'var_b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
     <span class="s">'var_c'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],}</span>
</code></pre></div></div>

<p>이렇게 정의된 딕셔너리의 각 요소는 <code class="highlighter-rouge">d['var_a']</code>와 같이 접근할 수 있지요.</p>

<p>한편, 경우에 따라서 <code class="highlighter-rouge">print(d['var_a'])</code>처럼 사용하는 것보다 <code class="highlighter-rouge">print(var_a)</code>처럼 변수로 만들어 사용하는 것이 편할 때가 있지요. 작업중이던 변수들을 딕셔너리로 묶어 <code class="highlighter-rouge">pickle.dump()</code>했다가 다시 <code class="highlighter-rouge">pickle.load()</code>할 때 등이 대표적인 경우이겠죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">exec</span><span class="p">(</span><span class="s">'</span><span class="si">%</span><span class="s">s = </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
</code></pre></div></div>

<p>위와 같이 하면 딕셔너리의 각 요소를 변수로 만들 수 있습니다. 두 줄짜리 간단한 코드지만 원하는 바를 쉽게 달성하게 해 주죠. 위 코드를 간단히 살펴 봅시다. <code class="highlighter-rouge">d.items()</code>는 딕셔너리를 키(key)와 값(value)의 쌍으로 나열시키고, 이를 <code class="highlighter-rouge">for</code>로 iteration합니다. 각 iteration에서 키를 변수명으로 삼아 변수에 값을 할당하는 구문을 문자열로 만들고 이 문자열을 <code class="highlighter-rouge">exec()</code>에 입력시킵니다. <code class="highlighter-rouge">exec()</code>은 말그대로 주어진 문자열을 Python 구문으로 여겨 실행시키지요.</p>

<p>생각보다 간단하고 짧은 <code class="highlighter-rouge">for</code> 루프만으로 딕셔너리 각 요소의 변수로의 전환이 가능하지요?</p>

	  ]]></description>
	</item>

	<item>
	  <title>numpy의 argmax(), argmin() 그리고 argwhere() - 최대, 최소, 특정 값 찾기</title>
	  <link>//numpy-argmax-argmin-argwhere</link>
	  <author></author>
	  <pubDate>2019-04-13T08:55:00+09:00</pubDate>
	  <guid>//numpy-argmax-argmin-argwhere</guid>
	  <description><![CDATA[
	     <p>학부 저학년 시절 첫 프로그래밍 언어를 접할 때, 정수형 array에서 최대 값의 위치를 찾기 위해 자연스럽게 loop을 사용했습니다. 아래처럼 말이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">maximal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
<span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">maximal</span><span class="p">:</span>
        <span class="n">maximal</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">ix</span>
<span class="k">print</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">maximal</span><span class="p">)</span>
</code></pre></div></div>

<p>Python에 익숙해 지면서 max()와 같은 기본 메서드를 손쉽고 자연스럽게 사용하게 되었습니다. 그리고 Python을 매력적으로 만들었던 inline for loop도 자유자재로 쓰게 되면서 아래처럼 컴팩트한 코드를 작성할 수 있게 되었죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">([(</span><span class="n">ix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">maximum</span><span class="p">])</span>
</code></pre></div></div>

<p>numpy의 존재를 알게 되면서 큰 충격에 빠지지요. 이산수학 강의에서나 볼법한 수학 기호가 그대로 메서드로 구현되어 있더군요. inline for loop조차 구질구질해 보이게 만든 간결한 코드가 아래처럼 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="nb">max</span><span class="p">())</span>
</code></pre></div></div>

<p>numpy의 argmax(), argmin()을 이용해 최대, 최소 값의 위치를 손쉽게 알 수 있습니다. argwhere()를 사용하면 특정 데이터의 위치를 매우 간편히 찾을 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="nb">min</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<p>바로 위 코드에서 볼 수 있듯이 argwhere()의 용법은 argmax(), argmin()과 다소 다르니 참고하세요.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Pandas DataFrame(Series)의 문자열 contains(), startswith() 여러 값 적용하는 방법</title>
	  <link>//pandas-contains-multiple</link>
	  <author></author>
	  <pubDate>2019-01-23T08:30:00+09:00</pubDate>
	  <guid>//pandas-contains-multiple</guid>
	  <description><![CDATA[
	     <p>Pandas Series는 강력한 문자열 처리 기능을 갖고 있습니다. <code class="highlighter-rouge">Series.str.contains()</code>는 특정 문자열을 포함하는 요소를 찾아 주고 <code class="highlighter-rouge">Series.str.startswith()</code>, <code class="highlighter-rouge">Series.str.endswith()</code>는 특정 문자열로 시작되거나 끝나는 요소를 찾아 줍니다. Series뿐 아니라 DataFrame의 각 열(column)에 대해서도 앞서 말한 기능을 쓸 수 있습니다. <code class="highlighter-rouge">DataFrame['COL1'].str.contains()</code>처럼 쓰면 되지요. DataFrame에서 각 열은 Series이니 어찌 보면 당연한 얘기입니다.</p>

<p>가끔 작업을 하다 보면 여러 문자열 중 하나라도 포함하는 경우, 또는 여러 문자열 중 하나로라도 시작하는(끝나는) 경우를 따져야 할 경우가 생깁니다. <code class="highlighter-rouge">contains()</code>의 경우 ‘|‘(pipe)로 연결된(OR-ing) 문자열을 인자로 주면 되고, <code class="highlighter-rouge">startswith()</code>, <code class="highlighter-rouge">endswith()</code>의 경우 문자열의 tuple을 인자로 주면 됩니다. 이 방법을 알기 전까지는 <code class="highlighter-rouge">df.COL1.apply(lambda x: any(i in x for i in ['this', 'that']))</code>처럼 복잡한 코드 작성을 했었는데, 진작에 알았다면 이미 짠 많은 코드들이 간결하고 가독성 좋게 남아 있었겠지요.</p>

<p>아래는 <code class="highlighter-rouge">contains()</code>에 ‘|‘로 연결된 문자열을 인자로 준 사례입니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pandas as pd

names = ['jack', 'bob', 'watson', 'jake', 'mike', 'don', 'george', 'natasha', 'jill', 'ann', 'john', 'johnson']
ser = pd.Series(names)

ser[ser.str.contains('oh|son')]
# 2      watson
# 10       john
# 11    johnson
# dtype: object
</code></pre></div></div>

<p>아래는 <code class="highlighter-rouge">startswith()</code>에 문자열의 tuple을 인자로 준 사례입니다. <code class="highlighter-rouge">endswith()</code>에 대해서도 응용이 가능하지요.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ser[ser.str.startswith(('j', 'a',))]
# 0        jack
# 3        jake
# 8        jill
# 9         ann
# 10       john
# 11    johnson
dtype: object
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>Jekyll 블로그 사이트맵(sitemap) 설치(플러그인) 방법</title>
	  <link>//jekyll-sitemap-plugin-installation</link>
	  <author></author>
	  <pubDate>2019-01-17T07:30:00+09:00</pubDate>
	  <guid>//jekyll-sitemap-plugin-installation</guid>
	  <description><![CDATA[
	     <p>개인 블로그(홈페이지 등)의 페이지들이 Google 검색에 잘 노출되게 하기 위해 Google Search Console에 사이트맵(sitemap)을 제출해 두면 좋습니다. 바닐라 Jekyll에는 없지만, Jekyll 플러그인을 설치하면 Jekyll 블로그의 사이트맵을 빌드 때마다 자동 생성(xml)할 수 있습니다.</p>

<p>아래와 같이 우선 사이트맵 플러그인을 설치합니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo gem install jekyll-sitemap
</code></pre></div></div>
<p>Gemfile에 플러그인 설치 명령어를 추가해 둡니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nano Gemfile

... (파일 하단에 아래와 같이 추가) ...
gem 'jekyll-sitemap'
</code></pre></div></div>
<p>설정 파일 플러그인 부분에 설치된 플러그인을 추가합니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nano _config.yml

... (파일 내 plugins 부분을 아래와 같이 편집 - 내용 추가) ...
plugins [..., jekyll-sitemap]
</code></pre></div></div>
<p>이제 Jekyll 빌드를 다시 한 후 서버 구동해 보시지요.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo bundle exec jekyll build --verbose
sudo bundle exec jekyll serve --host 0.0.0.0 --port 7070
</code></pre></div></div>
<p>이제 <code class="highlighter-rouge">your.jekyll.blog.url/sitemap.xml</code>로 사이트맵 접속이 가능합니다. 이 주소를 Google Search Console에 사이트맵으로 제출하세요. 그러면 블로그 포스팅이 늘어날 때 Google이 보다 효율적으로 주소를 긁어 갈 수 있게 됩니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>메모리 덜 쓰고 Pandas DataFrame 병합을 빠르게 하는 방법(여러 개의 용량 큰 파일)</title>
	  <link>//pandas-dataframe-concat-efficiently</link>
	  <author></author>
	  <pubDate>2019-01-15T07:00:00+09:00</pubDate>
	  <guid>//pandas-dataframe-concat-efficiently</guid>
	  <description><![CDATA[
	     <p>여러 개의 Excel 파일(또는 csv, pickle 등)로부터 같은 형태의 DataFrame을 차례로 읽어 들여 하나의 큰 DataFrame으로 합치려 한다고 합시다. 각 Excel 파일의 DataFrame의 컬럼 목록은 모두 같다고 하죠. 실제 사례를 상상해 보면, 날짜별, 시간별 로그 데이터가 파일 형태로 저장되어 있는 경우를 생각해 볼 수 있겠네요.</p>

<p>가장 먼저 떠오르는 방법은 아래처럼 빈 DataFrame을 선언한 후 For Loop으로 각 파일을 읽어 붙이는 형태가 되겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 권장하지 않는 사례
import pandas as pd, os

base_dir = 'some/dir/path'

df_accum = pd.DataFrame() # 빈 DataFrame을 만듦.
for fname in os.listdir(base_dir):
    df_temp = pd.read_excel(os.path.join(base_dir, fname))
    df_accum = df_accum.append(df_temp) # 매 Loop에서 취해진 DataFrame을 앞서 정의한 빈 DataFrame에 붙임.
</code></pre></div></div>

<p>그러나 이 방법은 다음의 두 가지 이유에서 좋지 않습니다.</p>

<ol>
  <li>메모리를 많이 씁니다. <code class="highlighter-rouge">df_accum</code>은 점점 몸집이 커져 갑니다. Loop마다 커지는 몸집에 <code class="highlighter-rouge">df_temp</code>를 붙이는 작업은 메모리 사용 차원에서 비효율적입니다.</li>
  <li>속도가 느립니다. 크기가 큰 DataFrame을 <code class="highlighter-rouge">append()</code>하는 것보다 작은 것을 하는 게 더 빠를 것입니다. 그런 차원에서 몸집이 커져 가는 <code class="highlighter-rouge">df_accum</code>은 느린 속도의 주범입니다.</li>
</ol>

<p>실제로 pickle 기준으로 총 크기가 4.5GB인 데이터를 위와 같이 처리해 보면 속도가 매우 느린데다가 자칫하면 메모리 부족 오류(MemoryError)를 보게 되기도 합니다.(Windows 64-bit에 8GB RAM을 사용한다 하더라도 말이죠.)</p>

<p>메모리 효율성 차원에서는 사실 뾰족한 답이 없습니다. 다만, ‘조금이라도 메모리를 덜 낭비’하면서 속도는 훨씬 빨리 할 수 있는 방법이 있습니다. 아래처럼 For Loop에서 등장하는 DataFrame을 list에 담아 두고 마지막에 list 통째로 <code class="highlighter-rouge">pd.concat()</code>에 넣어 병합하는 방법입니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 권장하는 사례
import pandas as pd, os

base_dir = 'some/dir/path'

list_of_df = [] # 빈 list를 만듦.
for fname in os.listdir(base_dir):
    df_temp = pd.read_excel(os.path.join(base_dir, fname))
    list_of_df.append(df_temp) # 매 Loop에서 취해진 DataFrame을 위의 list에 적재함.
df_accum = pd.concat(list_of_df) # list 속 DataFrame들을 일괄 병합함.
</code></pre></div></div>

<p>말씀드린 것처럼 메모리 효율성을 급격하게 높일 수는 없겠지만, 속도 향상은 확실히 느낄 수 있을 것입니다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
