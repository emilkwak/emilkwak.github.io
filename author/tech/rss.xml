<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>emilkwak.github.io/</title>
   
   <link>https://emilkwak.github.io</link>
   <description>Python, Pandas를 Excel보다 사랑하는 직장인을 위한 블로그 </description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Python 토이 데이터셋 3대장 - Scikit-Learn, Statsmodels, Vega Datasets</title>
	  <link>//python-toy-datasets</link>
	  <author></author>
	  <pubDate>2020-08-10T09:30:00+09:00</pubDate>
	  <guid>//python-toy-datasets</guid>
	  <description><![CDATA[
	     <p>Pandas, NumPy, SciPy 등 Python 패키지 또는 Python 자체를 사용해서 데이터 처리를 하다 보면 연습용 데이터가 필요할 때가 있습니다. 데이터 처리는 여러 데이터에 걸쳐 두루 쓸 수 있는 공통의 기술이기 때문에 연습용 데이터를 충분히 확보하고 두루 다뤄 보는 것이 중요합니다. 연습용 데이터를 토이(toy) 데이터라고도 하는데 이와 같은 토이 데이터셋을 제공해 주는 패키지가 있어 있어 소개합니다. Scikit-Learn 패키지, Statsmodels 패키지, Vega Datasets 패키지에서 제공하는 토이 데이터셋을 차례로 소개할 예정입니다.</p>

<ul>
  <li>참고: <a href="https://python-data-science.readthedocs.io/en/latest/datasets.html">Data Science in Python - In-Built Datasets</a></li>
</ul>

<hr />

<h2 id="1-scikit-learn의-datasets-패키지">1. Scikit-Learn의 datasets 패키지</h2>

<p>머신러닝 교육을 위해 만들어진 Scikit-Learn은 원래 목적을 넘어서 개발 실무에도 널리 쓰이고 있죠? Scikit-Learn은 datasets 패키지를 통해 토이 데이터셋을 제공합니다. 단, 그 개수는 7개로 많지 않습니다만 머신러닝 작업을 Scikit-Learn으로 할 때 부담없이 간단히 사용할 수 있어 편리합니다.</p>

<ul>
  <li>참고: <a href="https://scikit-learn.org/stable/datasets/index.html#toy-datasets">(공식) Scikit-Learn - Toy datasets</a></li>
</ul>

<p>데이터를 읽어들여 Pandas의 DataFrame에 담아 편의성 있게 다룰 수 있게 해 보겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>

<span class="n">df_iris</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">iris</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="n">df_iris</span><span class="p">[</span><span class="s">'target'</span><span class="p">]</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="k">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">df_iris</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="s">'keys'</span><span class="p">))</span>

<span class="s">'''
       sepal length (cm)    sepal width (cm)    petal length (cm)    petal width (cm)    target
---  -------------------  ------------------  -------------------  ------------------  --------
 85                  6                   3.4                  4.5                 1.6         1
 52                  6.9                 3.1                  4.9                 1.5         1
  8                  4.4                 2.9                  1.4                 0.2         0
 68                  6.2                 2.2                  4.5                 1.5         1
 67                  5.8                 2.7                  4.1                 1           1
129                  7.2                 3                    5.8                 1.6         2
 76                  6.8                 2.8                  4.8                 1.4         1
145                  6.7                 3                    5.2                 2.3         2
105                  7.6                 3                    6.6                 2.1         2
  7                  5                   3.4                  1.5                 0.2         0
'''</span>
</code></pre></div></div>

<p>Scikit-Learn의 datasets 패키지로부터 iris 데이터셋을 불러 왔습니다. Scikit-Learn 토이 데이터셋은 DataFrame 형태로 제공되지 않기 때문에 얻어진 데이터를 DataFrame으로 전환하는 작업을 따로 해 줘야 합니다. <code class="highlighter-rouge">pd.DataFrame()</code>으로 <code class="highlighter-rouge">iris.data</code>를 DataFrame으로 전환했습니다. 이때 <code class="highlighter-rouge">columns</code>로 <code class="highlighter-rouge">iris.feature_names</code>를 설정해 DataFrame의 헤더명을 부여합니다. <code class="highlighter-rouge">iris.target</code>은 머신러닝 지도학습(supervised learning) 시 필요한 타겟(target) 또는 레이블(label)인데 이를 위한 컬럼을 별도로 생성해 줍니다.(<code class="highlighter-rouge">df_iris['target']</code>)</p>

<p>아울러 DataFrame의 내용을 보기 좋게 표시하기 위해 tabulate 패키지를 사용했습니다.</p>

<p>이 iris 데이터셋이 어떤 내용이고 각 컬럼이 무엇이며 타겟이 무엇을 나타내는지 등, 데이터셋에 대한 설명은 <code class="highlighter-rouge">iris.DESCR</code>에 기술되어 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">DESCR</span><span class="p">)</span>

<span class="s">'''
.. _iris_dataset:

Iris plants dataset
--------------------

**Data Set Characteristics:**

    :Number of Instances: 150 (50 in each of three classes)
    :Number of Attributes: 4 numeric, predictive attributes and the class

...
...
...

The famous Iris database, first used by Sir R.A. Fisher. The dataset is taken
from Fisher's paper. Note that it's the same as in R, but not as in the UCI
Machine Learning Repository, which has two wrong data points.

...
...
...
'''</span>
</code></pre></div></div>

<p>Scikit-Learn 토이 데이터셋은 iris 데이터셋을 포함해 총 7개인데 <code class="highlighter-rouge">import load_iris</code> 부분을 바꿔 가면서 다른 데이터셋을 불러 올 수 있습니다. 예를 들어 boston 데이터셋을 불러 오기 위해서는 <code class="highlighter-rouge">import load_boston</code>을 실행한 뒤 함수 호출을 <code class="highlighter-rouge">load_boston()</code>와 같이 하면 됩니다.</p>

<ul>
  <li>참고: 사용 가능한 토이 데이터셋 7개는 <code class="highlighter-rouge">load_boston</code>, <code class="highlighter-rouge">load_iris</code>, <code class="highlighter-rouge">load_diabetes</code>, <code class="highlighter-rouge">load_digits</code>, <code class="highlighter-rouge">load_linnerud</code>, <code class="highlighter-rouge">load_wine</code>, <code class="highlighter-rouge">load_breast_cancer</code>입니다.</li>
</ul>

<p>Scikit-Learn은 토이 데이터셋 외에도 실제(real word) 데이터셋 또한 제공합니다. 실제 데이터셋 또한 연습용으로 쓸 수 있지만 데이터의 용량이 크기 때문에(수십 MB 또는 그 이상) 실제적이고 양이 많은 데이터가 필요한 경우에 한해 사용하는 게 좋습니다.</p>

<ul>
  <li>참고: <a href="https://scikit-learn.org/stable/datasets/index.html#real-world-datasets">참고: (공식) Scikit-Learn - Real word datasets</a></li>
</ul>

<hr />

<h2 id="2-statsmodels의-datasets-패키지">2. Statsmodels의 datasets 패키지</h2>

<p>데이터 과학 분야의 주요 도구로서 Python과 쌍벽을 이루던 R이 있습니다. R은 Python보다 역사가 길어서 데이터셋 또한 매우 풍부합니다. Statsmodels는 datasets 패키지의 <code class="highlighter-rouge">get_rdataset()</code> 함수를 통해 R이 제공하는 데이터를 Python에서도 이용할 수 있게 해 줍니다.</p>

<ul>
  <li>참고: <a href="https://www.statsmodels.org/devel/datasets/index.html">(공식) Statsmodels - The Datasets Package</a></li>
</ul>

<p>데이터를 불러 와 DataFrame에 담아 줘야 했던 Scikit-Learn과 달리, Statsmodels는 DataFrame 상태로 데이터를 제공합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="n">ces11</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">get_rdataset</span><span class="p">(</span><span class="s">'CES11'</span><span class="p">,</span> <span class="s">'carData'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">ces11</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="s">'keys'</span><span class="p">))</span>

<span class="s">'''
        id  province      population    weight  gender    abortion    importance    education    urban
----  ----  ----------  ------------  --------  --------  ----------  ------------  -----------  -------
1761  2050  QC               5996930   6153.85  Female    No          not           higher       rural
 535  2297  QC               5996930   6153.85  Female    Yes         notvery       lessHS       urban
 778  2164  QC               5996930   6153.85  Male      No          notvery       college      rural
 149  1830  NS                729545   6399.52  Male      Yes         very          HS           rural
1459   248  SK                734250   7082.8   Male      No          very          HS           rural
1205  3189  ON               9439960   4488.81  Female    No          somewhat      lessHS       urban
 902   527  ON               9439960  13466.4   Male      No          somewhat      bachelors    urban
2009  1948  AB               2515180  17406.1   Female    No          somewhat      college      urban
1198  1186  ON               9439960   8977.61  Male      No          somewhat      college      urban
1821  1488  ON               9439960   8977.61  Male      No          notvery       bachelors    urban
'''</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">get_rdataset()</code>에서 얻어진 데이터를 <code class="highlighter-rouge">ces11</code> 변수에 담고 <code class="highlighter-rouge">ces11.data</code>를 사용하면 바로 DataFrame에 담겨진 데이터를 쓸 수 있게 됩니다. 그리고 타겟(레이블) 또한 이미 이 DataFrame에 포함되어 있는 상태이지요.(urban 컬럼) 데이터셋의 내용, 컬럼별 정의, 타겟의 의미 등은 <code class="highlighter-rouge">ces11.__doc__</code>으로 확인할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">ces11</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

<span class="s">'''
===== ===============
CES11 R Documentation
===== ===============

2011 Canadian National Election Study, With Attitude Toward Abortion
--------------------------------------------------------------------

Description
~~~~~~~~~~~

Data are drawn from the 2011 Canadian National Election Study, including
a question on banning abortion and variables related to the sampling
design.

...
...
...

Details
~~~~~~~

This is an extract from the data set for the 2011 Canadian National
Election Study distributed by the Institute for Social Research, York
University.

...
...
...
'''</span>
</code></pre></div></div>

<p>R의 데이터셋은 종류가 매우 다양하고 양이 무척 많습니다. 당연히 모든 종류를 기억할 수 없습니다. 다음 목록을 보고 필요에 따라 찾아 사용해야 합니다.</p>

<ul>
  <li>참고: <a href="https://vincentarelbundock.github.io/Rdatasets/articles/data.html">Rdatasets - List of Datasets</a></li>
</ul>

<p>위 목록을 보고 <code class="highlighter-rouge">get_rdataset()</code>에 해당하는 인자를 잘 설정해 호출해 주면 데이터를 얻을 수 있습니다. 인자를 설정하는 법은 간단합니다. 목록의 패키지(package)와 아이템(item)을 찾아서 아래처럼 함수를 호출해 보시죠.</p>

<ul>
  <li><code class="highlighter-rouge">get_rdataset()</code> 호출 방법: <code class="highlighter-rouge">get_rdataset(item, package)</code></li>
</ul>

<p>예를 들어 목록 페이지 가장 위에 존재하는 Monthly Excess Return 자료는 패키지가 boot, 아이템이 acme이니 <code class="highlighter-rouge">sm.datasets.get_rdataset('acme', 'boot')</code>와 같이 호출할 수 있겠죠?</p>

<hr />

<h2 id="3-vega-datasets의-data-패키지">3. Vega Datasets의 data 패키지</h2>

<p>마지막으로 Vega 데이터셋의 data 패키지를 이용해 보겠습니다.</p>

<ul>
  <li>참고: <a href="https://github.com/vega/vega-datasets/blob/master/SOURCES.md">(공식 - 데이터셋) Vega Datasets</a></li>
  <li>참고: <a href="https://github.com/jakevdp/vega_datasets">(공식 - 패키지) vega_datasets 패키지</a></li>
</ul>

<p>Vega 데이터셋도 데이터를 DataFrame 형태로 바로 제공하고 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">vega_datasets</span> <span class="kn">import</span> <span class="n">data</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="n">airports</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">airports</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">airports</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="s">'keys'</span><span class="p">))</span>

<span class="s">'''
      iata    name                        city          state    country      latitude    longitude
----  ------  --------------------------  ------------  -------  ---------  ----------  -----------
 301  35A     Union County, Troy Shelton  Union         SC       USA           34.6868     -81.6412
 936  BDX     Broadus                     Broadus       MT       USA           45.4333    -105.417
1739  HNR     Harlan Municipal            Harlan        IA       USA           41.5844     -95.3396
1672  H05     Wilburton Municipal         Wilburton     OK       USA           34.9195     -95.3947
 270  2O3     Angwin-Parrett              Angwin        CA       USA           38.5785    -122.435
1295  DRI     Beauregard Parish           De Ridder     LA       USA           30.8315     -93.3396
 895  AVO     Avon Park Municipal         Avon Park     FL       USA           27.5911     -81.5279
 846  ANY     Anthony Municipal           Anthony       KS       USA           37.1585     -98.0796
2696  PVC     Provincetown Municipal      Provincetown  MA       USA           42.072      -70.2214
2514  ONM     Socorro Municipal           Socorro       NM       USA           34.0225    -106.903
'''</span>
</code></pre></div></div>

<p>Vega 데이터셋은 데이터 불러오는 방법이 조금 특이하지요? 데이터셋 제목(여기서는 airports)을 함수처럼 호출하는 방식입니다. <code class="highlighter-rouge">data.airports()</code> 호출에 의해 airports 데이터셋이 불려 온 것이지요. 마찬가지로 만약 budgets 데이터셋을 불러오려 한다면 <code class="highlighter-rouge">data.budgets()</code>와 같이 호출하면 되겠습니다.</p>

<p>데이터셋에 대한 설명은 <code class="highlighter-rouge">data.airports.description</code>과 같은 구문으로 확인 가능합니다. 데이터셋 불러올 때는 함수 호출(<code class="highlighter-rouge">airports()</code>) 형태를 썼지만, 설명을 불러 올 때는 호출자에 쓰이는 괄호가 없다는 점에 유의해 주십시오. Vega 데이터셋의 데이터 설명은 앞의 두 패키지에 비해 조금 간략한 면이 있네요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">airports</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

<span class="s">'''
This dataset lists US airports, including airport code, city, state, latitude, and longitude. This dataset is a subset of the data compiled and published at http://ourairports.com/data/, and is in the public domain.
'''</span>
</code></pre></div></div>

<p>Vega 데이터셋의 데이터 종류는 다음 링크를 통해서 확인할 수 있고, 패키지 자체적으로 목록을 확인할 수 있는 함수도 제공합니다.(<code class="highlighter-rouge">data.list_datasets()</code>)</p>

<ul>
  <li>참고: <a href="https://github.com/vega/vega-datasets/blob/master/SOURCES.md">(공식) Vega Datasets - Sources</a></li>
</ul>

<hr />

<p>이상으로 쉽고 간편하게 쓸 수 있는 토이 데이터셋 세 가지, Scikit-Learn 데이터셋, Statsmodels R 데이터셋, Vega 데이터셋에 대해 알아 보았습니다. 토이 데이터셋을 통한 연습으로 쌓은 분석 및 처리 기술이 보다 방대한 실제 데이터를 자유자재로 다루는 데 도움이 되기를 기대합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>NumPy(넘파이) PyInstaller 패키징 시 실행파일(exe) 용량이 너무 큰 경우 해결책</title>
	  <link>//numpy-pyinstaller-size-too-big</link>
	  <author></author>
	  <pubDate>2020-04-13T00:00:00+09:00</pubDate>
	  <guid>//numpy-pyinstaller-size-too-big</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">PyInstaller</code>는 Python 프로그램 배포를 목적으로 많은 분들이 사용하는 패키지입니다. <code class="highlighter-rouge">cx_Freeze</code>나 <code class="highlighter-rouge">py2exe</code> 등 같은 용도의 패키지가 대체재로 존재하지만 사용법이 간단해 더 인기가 있습니다.</p>

<p><code class="highlighter-rouge">NumPy</code>는 Python 사용자라면 한번쯤 사용해 본 패키지일 것입니다. Python이 대중적인 데이터 분석용 언어로 각광받게 만든 패키지 중 하나가 <code class="highlighter-rouge">NumPy</code>라 보아도 무방하지요.(다른 하나는 <code class="highlighter-rouge">pandas</code>라 할 수 있지요.)</p>

<p>Windows 10 환경에서 <code class="highlighter-rouge">NumPy</code>를 사용하는 Python 프로그램을 작성한 후 <code class="highlighter-rouge">PyInstaller</code>로 패키징하면 패키징된 용량이 지나치게 큰 경향이 있어 의아한 분들이 많을 것입니다. <code class="highlighter-rouge">NumPy</code>를 포함해 두세 개 패키지만 <code class="highlighter-rouge">import</code>했는데 용량이 200 ~ 300MB라니, 당혹스럽지 않을 수 없습니다.</p>

<p>혹시, Windows 10에 Ananconda나 Miniconda를 설치해 쓰고 계신 가운데, <code class="highlighter-rouge">NumPy</code> 패키지를 <code class="highlighter-rouge">conda</code>로 설치하지는 않았나요? Anaconda 또는 Miniconda를 쓰는 것은 상관 없지만, <code class="highlighter-rouge">NumPy</code>를 <code class="highlighter-rouge">conda install numpy</code>로 설치한 경우 <code class="highlighter-rouge">PyInstaller</code> 패키징 용량이 매우 커진다는 사실을 발견했습니다. 반면, <code class="highlighter-rouge">pip</code>로 설치하면 적정한 수준의 용량으로 패키징이 가능합니다.</p>

<p>이는 <code class="highlighter-rouge">conda install numpy</code> 시 mkl 계열의 dll 파일이 대거 패키징되기 때문입니다. 한편, 똑같은 <code class="highlighter-rouge">NumPy</code>를 <code class="highlighter-rouge">pip</code>로 설치하면 mkl 계열 dll이 제외되는데 덕분에 용량을 덜 차지하지요. 실제 용량 차이가 어느정도까지 나는지 실험을 통해 알아봤습니다.</p>

<p>실험의 공통적인 시스템 환경은 다음과 같습니다.</p>

<ul>
  <li>Windows 10, 64비트, Anaconda 3 설치</li>
  <li>Python 3.7</li>
  <li>Python 가상환경 <code class="highlighter-rouge">conda create</code>로 생성</li>
  <li><code class="highlighter-rouge">PyInstaller</code>: 3.6</li>
  <li><code class="highlighter-rouge">NumPy</code>
    <ul>
      <li><code class="highlighter-rouge">conda install</code>: 1.18.1</li>
      <li><code class="highlighter-rouge">pip install</code>: 1.18.2</li>
    </ul>
  </li>
</ul>

<h2 id="실험-1-conda-install-numpy-후-pyinstaller-패키징">실험 1: <code class="highlighter-rouge">conda install numpy</code> 후 <code class="highlighter-rouge">PyInstaller</code> 패키징</h2>

<p>우선 Python 3.7 기준의 Python 가상환경을 만들고, <code class="highlighter-rouge">NumPy</code>를 <code class="highlighter-rouge">conda install</code>로 설치합니다. <code class="highlighter-rouge">PyInstaller</code>까지 설치(<code class="highlighter-rouge">pip install</code>로)합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create -n numpy_from_conda python=3.7
conda activate numpy_from_conda
conda install numpy
pip install pyinstaller
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">NumPy</code>를 쓰는 간단한 Python 프로그램을 작성합니다. 임의의 행렬 두 개를 행렬곱하는 예제입니다. 오로지 <code class="highlighter-rouge">NumPy</code>만 <code class="highlighter-rouge">import</code>해 사용한 간단한 소스코드라고 할 수 있지요. 똑같은 예제를 두 번째 <code class="highlighter-rouge">pip install numpy</code> 실험에도 사용할 예정입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># matmul_example.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">mat_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">mat_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mat_a</span><span class="p">,</span> <span class="n">mat_b</span><span class="p">)</span>
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">PyInstaller</code>로 패키징을 해 보겠습니다. <code class="highlighter-rouge">--onefile</code> 옵션을 적용한 경우와 그렇지 않은 경우, 두 경우를 모두 보겠습니다. 참고로, <code class="highlighter-rouge">numpy_from_conda</code>로 <code class="highlighter-rouge">conda activate</code>된 상태를 유지해야 합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyinstaller --onefile matmul_example.py
dir dist\matmul_example.exe

2020-04-11  오후 ..:..       206,681,582 matmul_example.exe
               1개 파일         206,681,582 바이트
</code></pre></div></div>

<p><code class="highlighter-rouge">--onefile</code> 옵션 없이 패키징하면 어떻게 될까요?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyinstaller --onefile matmul_example.py
dir dist\matmul_example

2020-04-11  오후 ..:..    &lt;DIR&gt;          .
2020-04-11  오후 ..:..    &lt;DIR&gt;          ..
2020-04-11  오후 ..:..         3,554,703 matmul_example.exe
2020-04-11  오후 ..:..             1,037 matmul_example.exe.manifest
2020-04-03  오후 ..:..            19,208 api-ms-win-core-console-l1-1-0.dll
2020-04-03  오후 ..:..            18,696 api-ms-win-core-datetime-l1-1-0.dll
2020-04-03  오후 ..:..            18,696 api-ms-win-core-debug-l1-1-0.dll
.......
2020-04-11  오후 ..:..    &lt;DIR&gt;          mkl
2020-04-06  오전 ..:..        43,504,000 mkl_avx.dll
2020-04-06  오전 ..:..        40,924,032 mkl_avx2.dll
2020-04-06  오전 ..:..        51,629,952 mkl_avx512.dll
.......
2020-04-06  오전 ..:..        71,339,904 mkl_core.dll
2020-04-06  오전 ..:..        35,575,168 mkl_def.dll
2020-04-06  오전 ..:..        32,865,664 mkl_intel_thread.dll
2020-04-06  오전 ..:..        41,196,416 mkl_mc.dll
2020-04-06  오전 ..:..        42,454,400 mkl_mc3.dll
.......
2020-04-06  오전 ..:..        28,328,832 mkl_pgi_thread.dll
2020-04-06  오전 ..:..        15,146,880 mkl_rt.dll
2020-04-06  오전 ..:..         7,586,176 mkl_scalapack_ilp64.dll
2020-04-06  오전 ..:..         7,527,296 mkl_scalapack_lp64.dll
2020-04-06  오전 ..:..        18,359,168 mkl_sequential.dll
2020-04-06  오전 ..:..        20,887,936 mkl_tbb_thread.dll
2020-04-06  오전 ..:..        13,028,224 mkl_vml_avx.dll
2020-04-06  오전 ..:..        12,949,376 mkl_vml_avx2.dll
2020-04-06  오전 ..:..        12,604,800 mkl_vml_avx512.dll
2020-04-06  오전 ..:..         6,645,632 mkl_vml_cmpt.dll
2020-04-06  오전 ..:..         6,877,056 mkl_vml_def.dll
2020-04-06  오전 ..:..        12,032,896 mkl_vml_mc.dll
2020-04-06  오전 ..:..        11,888,512 mkl_vml_mc2.dll
2020-04-06  오전 ..:..        11,977,088 mkl_vml_mc3.dll
...
              91개 파일         565,684,976 바이트
</code></pre></div></div>

<p>요컨대 <code class="highlighter-rouge">--onefile</code> 때는 206MB, <code class="highlighter-rouge">--onefile</code> 아닐 때는 무려 565MB로 패키징됩니다. 행렬곱 하나 하는 장난감 프로그램의 크기가 이정도라는 게 말이 안되지요? mkl 계열 dll들이 큰 용량의 주범인데 이것들을 어떻게 제외시킬 수 있을까요?</p>

<h2 id="실험-2-pip-install-numpy-후-pyinstaller-패키징">실험 2: <code class="highlighter-rouge">pip install numpy</code> 후 <code class="highlighter-rouge">PyInstaller</code> 패키징</h2>

<p>이번에는 Python 3.7 기준 가상환경을 만들고, <code class="highlighter-rouge">NumPy</code>를 <code class="highlighter-rouge">pip install</code>로 설치합니다. <code class="highlighter-rouge">PyInstaller</code>까지 설치합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create -n numpy_from_pip python=3.7
conda activate numpy_from_pip
pip install numpy pyinstaller
</code></pre></div></div>

<p>첫 번째 실험(<code class="highlighter-rouge">conda install numpy</code>)때의 예제 프로그램을 <code class="highlighter-rouge">PyInstaller</code>로 패키징해 보겠습니다. <code class="highlighter-rouge">numpy_from_pip</code>로 <code class="highlighter-rouge">conda activate</code>된 상태여야 합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyinstaller --onefile matmul_example.py
dir dist\matmul_example.exe

2020-04-11  오후 ..:..        19,334,062 matmul_example.exe
               1개 파일          19,334,062 바이트
</code></pre></div></div>

<p><code class="highlighter-rouge">--onefile</code> 옵션을 적용해 보겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyinstaller --onefile matmul_example.py
dir dist\matmul_example

2020-04-11  오후 ..:..    &lt;DIR&gt;          .
2020-04-11  오후 ..:..    &lt;DIR&gt;          ..
2020-04-11  오후 ..:..         3,554,246 matmul_example.exe
2020-04-11  오후 ..:..             1,037 matmul_example.exe.manifest
2020-04-03  오후 ..:..            19,208 api-ms-win-core-console-l1-1-0.dll
2020-04-03  오후 ..:..            18,696 api-ms-win-core-datetime-l1-1-0.dll
2020-04-03  오후 ..:..            18,696 api-ms-win-core-debug-l1-1-0.dll
...
              59개 파일          49,431,319 바이트
</code></pre></div></div>

<p><code class="highlighter-rouge">--onefile</code> 때는 19MB, <code class="highlighter-rouge">--onefile</code> 아닐 때는 49MB로 패키징됩니다. 뭔가 딱 예상했던, 적정해 보이는 크기이죠? mkl 계열 dll이 하나도 생성되지 않았음을 볼 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir dist\matmul_example

파일을 찾을 수 없습니다.
</code></pre></div></div>

<p><code class="highlighter-rouge">PyInstaller</code>를 사용한 Python 프로그램 패키징 배포 시 용량이 과도하게 크다 싶으면 <code class="highlighter-rouge">NumPy</code>가 <code class="highlighter-rouge">conda</code>로 설치되었는지 확인해 보시고 그렇다면 <code class="highlighter-rouge">pip</code>로 재설치해 보시기 바랍니다. 매우 간단한 행렬곱 프로그램을 패키징하는데, <code class="highlighter-rouge">--onefile</code> 기준으로 19MB면 되었을 것이 206MB가 될 뻔 했으니까요.(<code class="highlighter-rouge">--onefile</code> 아닌 경우에는 더 심각합니다. 49MB vs. 565MB이니까요.)</p>

<h2 id="참고자료">참고자료</h2>
<ul>
  <li><a href="https://github.com/pyinstaller/pyinstaller/issues/2270">MKL DLLs cannot be excluded using –exclude-module</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>DataFrame(데이터프레임)에 list(리스트)를 행 추가하기 & ignore_index 관련 TypeError 처리</title>
	  <link>//dataframe-list-row-append-ignore-index</link>
	  <author></author>
	  <pubDate>2020-04-13T00:00:00+09:00</pubDate>
	  <guid>//dataframe-list-row-append-ignore-index</guid>
	  <description><![CDATA[
	     <p>이미 있는 <code class="highlighter-rouge">DataFrame</code>(데이터프레임)에 행(row)으로 추가할 데이터가 <code class="highlighter-rouge">list</code>(리스트)로 주어져 있다면 어떻게 해야 할까요? 데이터 재료부터 준비해 봅시다.</p>

<p>참고로, 편의상 <code class="highlighter-rouge">DataFrame</code>을 출력하기 위해 <code class="highlighter-rouge">tabulate</code> 패키지를 활용한 <code class="highlighter-rouge">print_df()</code>를 정의해 사용하였습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="c"># DataFrame 출력을 위해 tabulate 패키지 활용</span>
<span class="k">def</span> <span class="nf">print_df</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s">'keys'</span><span class="p">,</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s">'psql'</span><span class="p">))</span>

<span class="c"># 이미 있던 DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s">'abcde'</span><span class="p">))</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+
|    |   a |   b |   c |   d |   e |
|----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 |
|  1 |   5 |   6 |   7 |   8 |   9 |
|  2 |  10 |  11 |  12 |  13 |  14 |
|  3 |  15 |  16 |  17 |  18 |  19 |
|  4 |  20 |  21 |  22 |  23 |  24 |
+----+-----+-----+-----+-----+-----+
'''</span>

<span class="c"># 행으로 추가할 list</span>
<span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">102</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">105</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="s">'''
[101, 102 103, 104, 105]
'''</span>
</code></pre></div></div>

<p>쉬운 생각으로, 다음과 같이 하면 될 것 같지요? 그런데 그렇게 하면 조금 이상한 결과가 나옵니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+-----+
|----+-----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 | nan |
|  1 |   5 |   6 |   7 |   8 |   9 | nan |
|  2 |  10 |  11 |  12 |  13 |  14 | nan |
|  3 |  15 |  16 |  17 |  18 |  19 | nan |
|  4 |  20 |  21 |  22 |  23 |  24 | nan |
|  0 | nan | nan | nan | nan | nan | 101 |
|  1 | nan | nan | nan | nan | nan | 102 |
|  2 | nan | nan | nan | nan | nan | 103 |
|  3 | nan | nan | nan | nan | nan | 104 |
|  4 | nan | nan | nan | nan | nan | 105 |
+----+-----+-----+-----+-----+-----+-----+
'''</span>
</code></pre></div></div>

<p>왜 이럴까요? <code class="highlighter-rouge">DataFrame</code>에 <code class="highlighter-rouge">list</code>가 <code class="highlighter-rouge">append()</code>로 주어지면 <code class="highlighter-rouge">pandas</code>는 이를 행이 아닌 열 데이터로 인식하기 때문입니다. 그렇다면 <code class="highlighter-rouge">list</code>를 <code class="highlighter-rouge">Series</code>(시리즈)로 만들어서 해보면 어떨까요?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df3</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
<span class="c"># TypeError: Can only append a Series if ignore_index=True or if the Series has a name</span>
</code></pre></div></div>

<p>잠깐! <code class="highlighter-rouge">TypeError</code>가 발생했군요. <code class="highlighter-rouge">TypeError: Can only append a Series if ignore_index=True or if the Series has a name</code>가 의미하는 것은 무엇일까요? 새로 추가되는 <code class="highlighter-rouge">Series</code>는 행 데이터이기는 하지만 행의 이름으로서의 인덱스(index)가 없는 데이터이기 때문입니다. 인덱스를 명시적으로 부여하거나 ‘아무 인덱스가 부여되도 상관 없으니 무시하라’는 의사를 표시해야 합니다.</p>

<p>인덱스를 명시적으로 주려면 <code class="highlighter-rouge">Series</code>에 <code class="highlighter-rouge">name</code>을 부여해야 합니다. 즉, <code class="highlighter-rouge">DataFrame</code>에 <code class="highlighter-rouge">Series</code>가 <code class="highlighter-rouge">append()</code>될 때 <code class="highlighter-rouge">Series</code>가 갖고 있는 <code class="highlighter-rouge">name</code>이 새로 만들어질 행의 인덱스가 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df4</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df4</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
|    |   a |   b |   c |   d |   e |   0 |   1 |   2 |   3 |   4 |
|----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 | nan | nan | nan | nan | nan |
|  1 |   5 |   6 |   7 |   8 |   9 | nan | nan | nan | nan | nan |
|  2 |  10 |  11 |  12 |  13 |  14 | nan | nan | nan | nan | nan |
|  3 |  15 |  16 |  17 |  18 |  19 | nan | nan | nan | nan | nan |
|  4 |  20 |  21 |  22 |  23 |  24 | nan | nan | nan | nan | nan |
| 10 | nan | nan | nan | nan | nan | 101 | 102 | 103 | 104 | 105 |
+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
'''</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">name</code>을 임의로 <code class="highlighter-rouge">10</code>으로 줬더니 기존 <code class="highlighter-rouge">DataFrame</code>의 인덱스와 연결성이 깨지는 결번 현상이 발생했습니다. 다른 방법, 즉, ‘아무 인덱스가 부여되도 상관 없으니 무시하라’는 의사를 표시하는 방법을 쓰면 결번 현상을 막을 수 있습니다. <code class="highlighter-rouge">append()</code>에 <code class="highlighter-rouge">ignore_index=True</code>를 인자로 주면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df5</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df5</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
|    |   a |   b |   c |   d |   e |   0 |   1 |   2 |   3 |   4 |
|----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 | nan | nan | nan | nan | nan |
|  1 |   5 |   6 |   7 |   8 |   9 | nan | nan | nan | nan | nan |
|  2 |  10 |  11 |  12 |  13 |  14 | nan | nan | nan | nan | nan |
|  3 |  15 |  16 |  17 |  18 |  19 | nan | nan | nan | nan | nan |
|  4 |  20 |  21 |  22 |  23 |  24 | nan | nan | nan | nan | nan |
|  5 | nan | nan | nan | nan | nan | 101 | 102 | 103 | 104 | 105 |
+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
'''</span>
</code></pre></div></div>

<p>인덱스 결번 현상은 없어졌습니다. 자연스럽게 기존 <code class="highlighter-rouge">DataFrame</code>의 최대 인덱스를 1 증가(increment)시켜 새 인덱스로 삼았습니다. 그런데 해결되지 않은 문제가 남았습니다. <code class="highlighter-rouge">DataFrame</code>의 헤더는 a ~ e의 알파벳이었죠? 그런데 새로운 행은 0 ~ 4라는 숫자 헤더를 불필요하게 만들었습니다. 의도한 결과가 아닐 뿐더러, 쓸모 없는 <code class="highlighter-rouge">nan</code> 데이터도 무수히 생겨났지요. 아래처럼, <code class="highlighter-rouge">Series</code>에 인덱스를 설정해 <code class="highlighter-rouge">append()</code>하면 해결이 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df6</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df6</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+
|    |   a |   b |   c |   d |   e |
|----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 |
|  1 |   5 |   6 |   7 |   8 |   9 |
|  2 |  10 |  11 |  12 |  13 |  14 |
|  3 |  15 |  16 |  17 |  18 |  19 |
|  4 |  20 |  21 |  22 |  23 |  24 |
|  5 | 101 | 102 | 103 | 104 | 105 |
+----+-----+-----+-----+-----+-----+
'''</span>
</code></pre></div></div>

<p>깔끔하게 행 데이터로 삽입이 되었지요? 번외로 아래와 같은 트릭을 쓸 수도 있습니다. 위에서 논의한 방법과는 전혀 다른 방법입니다. 두 가지 방법 중 개인적으로 더 편리한 방법을 사용하면 될 것 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df7</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">df7</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
<span class="n">print_df</span><span class="p">(</span><span class="n">df7</span><span class="p">)</span>
<span class="s">'''
+----+-----+-----+-----+-----+-----+
|    |   a |   b |   c |   d |   e |
|----+-----+-----+-----+-----+-----|
|  0 |   0 |   1 |   2 |   3 |   4 |
|  1 |   5 |   6 |   7 |   8 |   9 |
|  2 |  10 |  11 |  12 |  13 |  14 |
|  3 |  15 |  16 |  17 |  18 |  19 |
|  4 |  20 |  21 |  22 |  23 |  24 |
|  5 | 101 | 102 | 103 | 104 | 105 |
+----+-----+-----+-----+-----+-----+
'''</span>
</code></pre></div></div>

<p>제대로 된 결과가 역시 잘 나왔습니다. 마지막 방법의 원리를 간단히 설명해 볼까요? 우선 기존 <code class="highlighter-rouge">DataFrame</code>의 마지막 행을 그대로 복제해 덧붙입니다. 덧붙여진 마지막 행에 <code class="highlighter-rouge">list</code>를 할당(assign)합니다. 마지막 행을 복제한 목적은 새로운 <code class="highlighter-rouge">list</code>가 삽입될 공간을 마련해 준 것뿐이지요.</p>

<p>메커니즘은 간단하지만, 앞서 위에서 설명한 방법과 비교할 때 ‘코딩량’은 크게 차이나지는 않습니다. 결국, 각자 스타일에 맞는 방법을 택하면 되겠지요?</p>

	  ]]></description>
	</item>

	<item>
	  <title>데이터프레임(DataFrame) 인덱싱(indexing), 셀렉팅(selecting)한 상태에서 값 수정하기(loc[] 사용)</title>
	  <link>//dataframe-update-after-indexing-selecting</link>
	  <author></author>
	  <pubDate>2020-02-03T08:00:00+09:00</pubDate>
	  <guid>//dataframe-update-after-indexing-selecting</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">pandas</code>를 사용하다 보면 <code class="highlighter-rouge">DataFrame</code>의 일부 행과 일부 열에 대해서만 부분적으로 수정을 가해야 할 때가 생깁니다. 인덱싱(indexing)과 셀렉팅(selecting)을 통해 수정을 가할 부분을 어떻게든 찾은 다음에, 어떤 방법을 써야 실제적인 수정이 이뤄지는지 알아 보겠습니다.</p>

<p>선 다음과 같은 샘플 데이터셋을 통해 <code class="highlighter-rouge">DataFrame</code>을 만들어 보겠습니다. Forbes가 발표한 2019년 미국 최우수 대학교 순위 자료입니다. 1위부터 10위까지만 추렸고 4개의 헤더(<code class="highlighter-rouge">RANK</code>, <code class="highlighter-rouge">NAME</code>, <code class="highlighter-rouge">STATE</code>, <code class="highlighter-rouge">SALARY</code>)는 각각 순위, 대학교명, 소재주, 평균초봉에 해당합니다.
(참고: <a href="https://www.forbes.com/top-colleges/#53e27aed1987">[Forbes] America’s Top Colleges 2019</a>)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s">'RANK'</span><span class="p">,</span> <span class="s">'NAME'</span><span class="p">,</span> <span class="s">'STATE'</span><span class="p">,</span> <span class="s">'SALARY'</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span>\
<span class="p">[[</span><span class="s">'1'</span><span class="p">,</span> <span class="s">'Harvard University'</span><span class="p">,</span> <span class="s">'Massachusetts'</span><span class="p">,</span> <span class="s">'74800'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'2'</span><span class="p">,</span> <span class="s">'Stanford University'</span><span class="p">,</span> <span class="s">'California'</span><span class="p">,</span> <span class="s">'79000'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'3'</span><span class="p">,</span> <span class="s">'Yale University'</span><span class="p">,</span> <span class="s">'Connecticut'</span><span class="p">,</span> <span class="s">'70300'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'4'</span><span class="p">,</span> <span class="s">'Massachusetts Institute of Technology'</span><span class="p">,</span> <span class="s">'Massachusetts'</span><span class="p">,</span> <span class="s">'86300'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'5'</span><span class="p">,</span> <span class="s">'Princeton University'</span><span class="p">,</span> <span class="s">'New Jersey'</span><span class="p">,</span> <span class="s">'75200'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'6'</span><span class="p">,</span> <span class="s">'University of Pennsylvania'</span><span class="p">,</span> <span class="s">'Pennsylvania'</span><span class="p">,</span> <span class="s">'72800'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'7'</span><span class="p">,</span> <span class="s">'Brown University'</span><span class="p">,</span> <span class="s">'Rhode Island'</span><span class="p">,</span> <span class="s">'68200'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'8'</span><span class="p">,</span> <span class="s">'California Institute of Technology'</span><span class="p">,</span> <span class="s">'California'</span><span class="p">,</span> <span class="s">'84100'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'9'</span><span class="p">,</span> <span class="s">'Duke University'</span><span class="p">,</span> <span class="s">'North Carolina'</span><span class="p">,</span> <span class="s">'71100'</span><span class="p">],</span>
 <span class="p">[</span><span class="s">'10'</span><span class="p">,</span> <span class="s">'Dartmouth College'</span><span class="p">,</span> <span class="s">'New Hampshire'</span><span class="p">,</span> <span class="s">'71500'</span><span class="p">]]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">SALARY</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">SALARY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div></div>
<p>위 <code class="highlighter-rouge">df</code> 변수에 완성된 데이터가 들어가 있습니다. 어떻게 생긴 데이터인지 한번 볼까요?</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="s">'''
	RANK	NAME	STATE	SALARY
0	1	Harvard University	Massachusetts	74800
1	2	Stanford University	California	79000
2	3	Yale University	Connecticut	70300
3	4	Massachusetts Institute of Technology	Massachusetts	86300
4	5	Princeton University	New Jersey	75200
5	6	University of Pennsylvania	Pennsylvania	72800
6	7	Brown University	Rhode Island	68200
7	8	California Institute of Technology	California	84100
8	9	Duke University	North Carolina	71100
9	10	Dartmouth College	New Hampshire	71500
'''</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">STATE</code>가 캘리포니아(California)인 것만 찾아 그 <code class="highlighter-rouge">STATE</code> CALIFORNIA로 변경해 보겠습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">STATE</span> <span class="o">==</span> <span class="s">'California'</span><span class="p">]</span><span class="o">.</span><span class="n">STATE</span> <span class="o">=</span> <span class="s">'CALIFORNIA'</span>
<span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="s">'''
/usr/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py:5208: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  self[name] = value
  
	RANK	NAME	STATE	SALARY
0	1	Harvard University	Massachusetts	74800
1	2	Stanford University	California	79000
2	3	Yale University	Connecticut	70300
3	4	Massachusetts Institute of Technology	Massachusetts	86300
4	5	Princeton University	New Jersey	75200
5	6	University of Pennsylvania	Pennsylvania	72800
6	7	Brown University	Rhode Island	68200
7	8	California Institute of Technology	California	84100
8	9	Duke University	North Carolina	71100
9	10	Dartmouth College	New Hampshire	71500
'''</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">SettingWithCopyWarning</code>이 발생했고 변경하려 했던 <code class="highlighter-rouge">df</code>의 부분도 바뀌지 않고 그대로 있습니다. 우리가 했던 변경 작업이 <code class="highlighter-rouge">df</code> 원본이 아니라 그것을 복사(copy)한 후 변경 처리한 결과라는 것입니다. 당연히 원본인 <code class="highlighter-rouge">df</code>는 아무런 영향을 받지 않은 것이고요.</p>

<p>그러면 어떻게 해야 할까요? 다음과 같이 <code class="highlighter-rouge">loc[]</code>와 <code class="highlighter-rouge">mask</code>를 이용한 방법이 가장 깔끔합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mask = df.STATE == 'California'
df.loc[mask, 'STATE'] = 'CALIFORNIA'
display(df)
'''
	RANK	NAME	STATE	SALARY
0	1	Harvard University	Massachusetts	74800
1	2	Stanford University	CALIFORNIA	79000
2	3	Yale University	Connecticut	70300
3	4	Massachusetts Institute of Technology	Massachusetts	86300
4	5	Princeton University	New Jersey	75200
5	6	University of Pennsylvania	Pennsylvania	72800
6	7	Brown University	Rhode Island	68200
7	8	California Institute of Technology	CALIFORNIA	84100
8	9	Duke University	North Carolina	71100
9	10	Dartmouth College	New Hampshire	71500
'''
</code></pre></div></div>
<p><code class="highlighter-rouge">STATE</code> 열을 보면 california였던 것이 모두 CALIFORNIA로 바뀌었습니다. 마찬가지 방법으로, 조금 더 복잡한 작업을 해 보시죠. 평균초봉이 80000 이상이면 대학교명을 모두 대문자 처리하는 코드를 작성해 보겠습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mask = df.SALARY &gt; 80000
df.loc[mask, 'NAME'] = df[mask].NAME.str.upper()
display(df)
'''
	RANK	NAME	STATE	SALARY
0	1	Harvard University	Massachusetts	74800
1	2	Stanford University	CALIFORNIA	79000
2	3	Yale University	Connecticut	70300
3	4	MASSACHUSETTS INSTITUTE OF TECHNOLOGY	Massachusetts	86300
4	5	Princeton University	New Jersey	75200
5	6	University of Pennsylvania	Pennsylvania	72800
6	7	Brown University	Rhode Island	68200
7	8	CALIFORNIA INSTITUTE OF TECHNOLOGY	CALIFORNIA	84100
8	9	Duke University	North Carolina	71100
9	10	Dartmouth College	New Hampshire	71500
'''
</code></pre></div></div>
<p>평균초봉이 86300인 MIT와 84100인 CALTECH, 두 군데의 학교명이 대문자 처리되었습니다. 세계적인 공과대학 두 곳인데, 역시 대단하군요.</p>

<p><code class="highlighter-rouge">DataFrame</code>을 인덱싱, 셀렉팅할 경우 원래의 <code class="highlighter-rouge">DataFrame</code>이 아닌 그것의 복사본을 생성해 반환하게 됩니다. 따라서 그것에 수정을 가해도 원본이 바뀌지는 않는 것입니다. 한편, <code class="highlighter-rouge">mask</code>와 <code class="highlighter-rouge">loc[]</code>을 이용하면 복사본을 생성하지 않고 원본을 유지하고 수정도 원본에 직접 가할 수 있습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>ast.literal_eval()로 문자열(str) 속 표현식(expression) 인식하기</title>
	  <link>//literal-eval-str-expression</link>
	  <author></author>
	  <pubDate>2020-02-02T07:00:00+09:00</pubDate>
	  <guid>//literal-eval-str-expression</guid>
	  <description><![CDATA[
	     <p>#</p>

<p>가만히 보면 Python 표현식(expression statement)도 문자열(str)입니다. 좀 애매한 말이지요? 예를 들어 <code class="highlighter-rouge">a = 1 + 2</code>라는 구문(statement)가 있을 때 ‘1 더하기 2’를 나타낸 우변도 결국 <code class="highlighter-rouge">'1 + 2'</code> 형태의 문자열이라는 것이지요.</p>

<p>Python 작업을 하다 보면 이렇게 문자열에 담겨 있는 표현식을 꺼내 써야 할 때가 종종 있습니다. 메모리에 있는 중간 처리 결과를 문자열로 출력한 후 메모장 같은 곳에 저장해 두었다가 나중에 쓰기도 합니다. 리스트(list) 표현식을 통째로 문자열로 메모해 두었다가 쓸 일도 많구요.</p>

<p>가령, 동창회 멤버 10명의 생년월일 데이터를 자주 사용하는 모임 총무가 있다고 칩시다. 길이(len)가 고작 10이고 각 요소(element)도 8자리 정수(int)인 자그마한 데이터를 굳이 <code class="highlighter-rouge">pickle</code> 같은 것을 사용해 보관할 필요는 없습니다.(오히려 번거롭지요.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">birth_day_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">'19950415'</span><span class="p">,</span> <span class="s">'19950527'</span><span class="p">,</span> <span class="s">'19951103'</span><span class="p">,</span> <span class="s">'19950606'</span><span class="p">,</span> <span class="s">'19950717'</span><span class="p">,</span> <span class="s">'19950327'</span><span class="p">,</span> <span class="s">'19951030'</span><span class="p">,</span> <span class="s">'19950424'</span><span class="p">,</span> <span class="s">'19950815'</span><span class="p">,</span> <span class="s">'19950901'</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">birth_day_list</span><span class="p">))</span> <span class="c"># 10</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">birth_day_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c"># 8</span>
</code></pre></div></div>
<p>대신 이 정도의 데이터는 Python 표현식 모양 그대로 메모장이나 클라우드 노트(Evernote, OneNote 따위)에 저장해 놓았다가 복사/붙여넣기로 다시 가져다 씁니다. 그런데 이렇게 문자열로 메모해 놓은 표현식이 한두 개면 몰라도 개수가 많아지면 매번 복사/붙여넣기 식으로 하기 번거로워집니다.</p>

<p>그렇다면 문자열로 기록된 표현식들을 일괄로 읽어 들여 와 Python 문자열 변수로 만들고 이를 이용해 원래의 Python 데이터를 얻어 내는 방법이 있을까요? 표현식의 일괄 읽기는 그렇게 어렵지 않습니다. <code class="highlighter-rouge">open()</code>과 <code class="highlighter-rouge">read()</code>, <code class="highlighter-rouge">readlines()</code> 등을 적절히 써 주면 됩니다. 관건은 ‘문자열 변수에 할당된 표현식으로부터 원래의 데이터를 얻는 방법’에 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_in_str</span> <span class="o">=</span> <span class="s">'[1, 2, 3, 4, 5]'</span>
<span class="n">list_data</span> <span class="o">=</span> <span class="n">list_in_str</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">list_data</span><span class="p">))</span> <span class="c"># str - wrong solution</span>
</code></pre></div></div>
<p>위 방법은 <code class="highlighter-rouge">list_in_str</code>을 그대로 재할당하는 작업일 뿐입니다. 그러면 어떻게 해야 <code class="highlighter-rouge">list_in_str</code>에 내포된 데이터를 복구해 낼 수 있을까요? <code class="highlighter-rouge">ast.literal_eval()</code>을 사용하는 것입니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ast</span>
<span class="n">list_in_str</span> <span class="o">=</span> <span class="s">'[1, 2, 3, 4, 5]'</span>
<span class="n">list_data</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">list_in_str</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">list_data</span><span class="p">))</span> <span class="c"># list - correct solution</span>
</code></pre></div></div>
<p>아래처럼 딕셔너리(dict)도 동일한 방법으로 처리가 가능합니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ast</span>
<span class="n">list_in_str</span> <span class="o">=</span> <span class="s">"{'a': 1, 'b': 2, 'c': 3}"</span>
<span class="n">list_data</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">list_in_str</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">list_data</span><span class="p">))</span> <span class="c"># dict</span>
</code></pre></div></div>
<p>사실 <code class="highlighter-rouge">eval()</code>이라는 내장(built-in) 함수가 있습니다. 그렇지만 이 함수는 악용될 소지가 커 가급적 사용을 자제해야 합니다.(참고: <a href="https://bluese05.tistory.com/64">python eval() 함수 - 사용을 조심해야 하는 이유</a>)</p>

<p>한편, <code class="highlighter-rouge">ast.literal_eval()</code>은 위에서 우리가 하려고 했던 목적을 이루게 해 주면서도, 안전성을 보장합니다. 정확히 이야기하자면, 인자(parameter)로 주어진 표현식을 실행하기 전에 그것이 ‘수상한 표현식’인지 아닌지 먼저 검증합니다.</p>

<p><code class="highlighter-rouge">ast.listeral_eval()</code>은 이처럼 안전한 대신 인자로, 제한된 리터럴(literal)로 구성된 표현식만 허용합니다. 즉, 다음과 같은 리터럴들만 표현식에 등장할 수 있다는 뜻이죠.</p>

<blockquote>
  <p>문자열, 바이트, 수, 튜플, 리스트, 딕셔너리, 셋, 불리언, None
(참고: <a href="https://docs.python.org/3/library/ast.html">ast — Abstract Syntax Trees</a>)</p>
</blockquote>

<p><code class="highlighter-rouge">eval()</code>이 내장 함수이기도 하고 Python이 아닌 다른 언어에도 보통 등장하는 기능이라, 무심코 사용하는 경향이 있습니다. 물론 개인적인 용도로 사용할 프로그램이거나 믿을 수 있는 사용자들만 사용할 프로그램이라면 괜찮겠으나, 믿을 수 있는 그룹이 아닌 불특정 다수 그룹이 사용할 것이라면, <code class="highlighter-rouge">eval()</code>의 사용을 최소한으로 하고 <code class="highlighter-rouge">ast.literal_eval()</code>과 같은 대체 기능을 사용해야 합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python의 itertools의 chain()으로 리스트(list) 붙이기(접합, concatenation)</title>
	  <link>//itertools-chain-list-concatenation-append</link>
	  <author></author>
	  <pubDate>2019-07-16T07:30:00+09:00</pubDate>
	  <guid>//itertools-chain-list-concatenation-append</guid>
	  <description><![CDATA[
	     <p>Python의 매력은 그 어떤 프로그래밍 언어보다 리스트(<code class="highlighter-rouge">list</code>) 다루는 방법이 우아(elegant)한 데 있습니다. 리스트 컴프리헨션(list comprehension)은 물론이거니와, <code class="highlighter-rouge">itertools</code>, <code class="highlighter-rouge">numpy</code>, <code class="highlighter-rouge">pandas</code> 같은 라이브러리도 이 우아함에 한 몫씩 하지요.</p>

<p>두 개의 리스트를 붙일(접합, concatenation) 때 단순히 덧셈 기호(<code class="highlighter-rouge">+</code>)를 쓰면 된다는 사실이 정말 기쁘지 않나요? 게다가 내장(built-in) 기능으로 말이지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shu_a</span> <span class="o">=</span> <span class="p">[</span><span class="s">'관우'</span><span class="p">,</span> <span class="s">'장비'</span><span class="p">,</span> <span class="s">'조운'</span><span class="p">,</span> <span class="s">'마초'</span><span class="p">,</span> <span class="s">'황충'</span><span class="p">,</span> <span class="s">'위연'</span><span class="p">]</span> <span class="c"># 삼국지 촉나라의 무장</span>
<span class="n">shu_b</span> <span class="o">=</span> <span class="p">[</span><span class="s">'제갈량'</span><span class="p">,</span> <span class="s">'방통'</span><span class="p">,</span> <span class="s">'서서'</span><span class="p">,</span> <span class="s">'강유'</span><span class="p">,</span> <span class="s">'법정'</span><span class="p">,</span> <span class="s">'마량'</span><span class="p">]</span> <span class="c"># 삼국지 촉나라의 무관</span>

<span class="n">shu_tot</span> <span class="o">=</span> <span class="n">shu_a</span> <span class="o">+</span> <span class="n">shu_b</span>
<span class="k">print</span><span class="p">(</span><span class="n">shu_tot</span><span class="p">)</span>
<span class="c"># ['관우', '장비', '조운', '마초', '황충', '위연', '제갈량', '방통', '서서', '강유', '법정', '마량']</span>
</code></pre></div></div>

<p>삼국지 촉나라의 무장과 문관이 각각의 리스트로 주어졌을 때 이를 덧셈 기호만으로 붙인 사례입니다. 덧셈에 덧셈, 덧셈에 다시 덧셈을 거듭해 많은 리스트를 계속 붙여 나갈 수 있겠지요? 그런데 이게 편하기만 할까요? 수학의 덧셈 기호는 이항 연산자입니다. Python 리스트 덧셈 또한 그렇지요. n개의 리스트를 붙이려면 덧셈 기호를 (n - 1)번이나 써 줘야 합니다. 다음처럼 말이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shu_tot</span> <span class="o">=</span> <span class="n">shu_1</span> <span class="o">+</span> <span class="n">shu_2</span> <span class="o">+</span> <span class="n">shu_3</span> <span class="o">+</span> <span class="err">…</span> <span class="o">+</span> <span class="n">shu_n</span>
</code></pre></div></div>

<p>붙일 리스트 개수가 대여섯 개만 넘어서도 덧셈 기호를 쓰기 귀찮아집니다. 루프(loop)를 써서 아래처럼 할 수도 있겠지만 Python스러운 방법은 아니지요. C/C++스러운 방법 아닌가요? 우리가 원하는 건 이게 아니지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shu_all</span> <span class="o">=</span> <span class="p">[</span><span class="n">shu_1</span><span class="p">,</span> <span class="n">shu_2</span><span class="p">,</span> <span class="n">shu_3</span><span class="p">,</span> <span class="err">…</span><span class="p">,</span> <span class="n">shu_n</span><span class="p">]</span>

<span class="n">shu_tot</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shu_all</span><span class="p">:</span>
	<span class="n">shu_tot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p>Python스러운 리스트 접합 방법은 <code class="highlighter-rouge">itertools</code>에서 찾을 수 있습니다. <code class="highlighter-rouge">itertools</code>의 <code class="highlighter-rouge">chain()</code> 메스드의 인자인 <code class="highlighter-rouge">*args</code>에 붙일 리스트들을 입력하여 붙여진 리스트를 얻을 수 있습니다. 연습용 데이터를 아래처럼 더 확장해 보시죠. 삼국지 위촉오의 무장과 문관 목록입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shu</span> <span class="o">=</span> <span class="p">([</span><span class="s">'관우'</span><span class="p">,</span> <span class="s">'장비'</span><span class="p">,</span> <span class="s">'조운'</span><span class="p">,</span> <span class="s">'마초'</span><span class="p">,</span> <span class="s">'황충'</span><span class="p">,</span> <span class="s">'위연'</span><span class="p">],</span> <span class="p">[</span><span class="s">'제갈량'</span><span class="p">,</span> <span class="s">'방통'</span><span class="p">,</span> <span class="s">'서서'</span><span class="p">,</span> <span class="s">'강유'</span><span class="p">,</span> <span class="s">'법정'</span><span class="p">,</span> <span class="s">'마량'</span><span class="p">])</span> <span class="c"># 삼국지 촉나라의 무장과 무관</span>
<span class="n">wei</span> <span class="o">=</span> <span class="p">([</span><span class="s">'하후돈'</span><span class="p">,</span> <span class="s">'장료'</span><span class="p">,</span> <span class="s">'서황'</span><span class="p">,</span> <span class="s">'우금'</span><span class="p">,</span> <span class="s">'악진'</span><span class="p">,</span> <span class="s">'장합'</span><span class="p">],</span> <span class="p">[</span><span class="s">'사마의'</span><span class="p">,</span> <span class="s">'순욱'</span><span class="p">,</span> <span class="s">'순유'</span><span class="p">,</span> <span class="s">'곽가'</span><span class="p">,</span> <span class="s">'가후'</span><span class="p">,</span> <span class="s">'정욱'</span><span class="p">])</span> <span class="c"># 삼국지 위나라의 무장과 무관</span>
<span class="n">wu</span> <span class="o">=</span> <span class="p">([</span><span class="s">'정보'</span><span class="p">,</span> <span class="s">'황개'</span><span class="p">,</span> <span class="s">'한당'</span><span class="p">,</span> <span class="s">'주태'</span><span class="p">,</span> <span class="s">'감녕'</span><span class="p">,</span> <span class="s">'태사자'</span><span class="p">],</span> <span class="p">[</span><span class="s">'주유'</span><span class="p">,</span> <span class="s">'노숙'</span><span class="p">,</span> <span class="s">'여몽'</span><span class="p">,</span> <span class="s">'육손'</span><span class="p">,</span> <span class="s">'제갈근'</span><span class="p">,</span> <span class="s">'장소'</span><span class="p">])</span> <span class="c"># 삼국지 오나라의 무장과 무관</span>
</code></pre></div></div>

<p>튜플(<code class="highlighter-rouge">tuple</code>) 속 리스트는 총 6개지요. 덧셈 기호로 붙일 생각을 하니 벌써부터 귀찮습니다. 굳이 한다면 다음과 같이 번거롭게 할 수 있겠지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tot</span> <span class="o">=</span> <span class="n">shu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wei</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wei</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span>
<span class="c"># ['관우', '장비', '조운', '마초', '황충', '위연', '제갈량', '방통', '서서', '강유', '법정', '마량', '하후돈', '장료', '서황', '우금', '악진', '장합', '사마의', '순욱', '순유', '곽가', '가후', '정욱', '정보', '황개', '한당', '주태', '감녕', '태사자', '주유', '노숙', '여몽', '육손', '제갈근', '장소']</span>
</code></pre></div></div>

<p>이번에는 같은 데이터를 <code class="highlighter-rouge">itertools</code>의 <code class="highlighter-rouge">chain()</code>으로 우아하게 붙여 볼까요?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="n">tot</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">shu</span><span class="p">,</span> <span class="o">*</span><span class="n">wei</span><span class="p">,</span> <span class="o">*</span><span class="n">wu</span><span class="p">))</span>
</code></pre></div></div>

<p>어떤가요? 별표 문법(asterisk/star syntax)으로 각 튜플을 풀어 헤치고 그것들을 <code class="highlighter-rouge">chain()</code>에 몽땅 집어 넣었더니 싹 다 붙었습니다. 간단(simple)하고 간소(compact)한 것 말고도 장점이 있습니다. 튜플에 들어 있는 리스트가 많거나 적어져도 코드에 손댈 필요가 없다는 점입니다. 확장적인(scalable) 구현이 가능해지는 것이죠.</p>

<p>별것 아닌 것 같아도, 때때로 수백, 수천 개의 리스트를 붙인 후 가공해야 할 일이 종종 생깁니다. 덧셈 기호를 쓰더라도 어떻게든 할 수는 있지만, 보다 Python스럽게 <code class="highlighter-rouge">itertools</code>의 <code class="highlighter-rouge">chain</code>을 써 보는 것은 어떨까요?</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 딕셔너리(dict) 대신 쓰는 디폴트딕트(defaultdict)</title>
	  <link>//defaultdict-rather-than-dict</link>
	  <author></author>
	  <pubDate>2019-07-10T07:30:00+09:00</pubDate>
	  <guid>//defaultdict-rather-than-dict</guid>
	  <description><![CDATA[
	     <p>딕셔너리 자료구조는 Python뿐 아니라 Java나 C++에서더 유용히 사용됩니다. Python의 딕셔너리는 <code class="highlighter-rouge">dict</code>라는 키워드로 선언되는데 Java 등에 비해 그 사용법이 간편하여 여러가지 용도로 자주 사용됩니다.</p>

<p>데이터 분석을 위한 데이터 처리 단계에서 튜플(<code class="highlighter-rouge">tuple</code>) 데이터를 다뤄야 하는 경우가 많습니다. 사실상 덩치가 큰 정형 데이터는 왠만하면 튜플의 리스트(<code class="highlighter-rouge">list</code>)로 주어진다고 해도 무방하지요. 이와 같이 튜플의 리스트 형태로 주어진 데이터를 능숙히 처리하는 게 데이터 분석의 중요 소양 중 하나이지요.</p>

<p>대표적인 경우가 딕셔너리(<code class="highlighter-rouge">dict</code>)에 데이터 주워 담기입니다. 딕셔너리의 키(key)로 군집화한 결과가 값(value)이 됩니다. 데이터를 잘 처리해 만든 딕셔너리 하나만으로도, Pandas 같은 라이브러리 없이도, 데이터 분석의 성과를 충분히 보여줄 수 있습니다. 그만큼 유용하게 중요하고 쓰이는 자료형이지요.</p>

<p>인구가 가장 많은 도시 순위 20위까지의 데이터가 주어졌을 때 어떤 국가의 도시가 순위에 많이 등장하는지 궁금할 수 있겠지요? 이 질문에 대한 대답을 찾기 위한 데이터 분석 과정을 거쳐 봅시다. 가장 간단하게는 다음과 같이 접근하겠죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cities</span> <span class="o">=</span>\
<span class="p">[(</span><span class="s">'Chongqing'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">30165500</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Shanghai'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">24183300</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Beijing'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">21707000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Istanbul'</span><span class="p">,</span> <span class="s">'Turkey'</span><span class="p">,</span> <span class="mi">15029231</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Karachi'</span><span class="p">,</span> <span class="s">'Pakistan'</span><span class="p">,</span> <span class="mi">14910352</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Dhaka'</span><span class="p">,</span> <span class="s">'Bangladesh'</span><span class="p">,</span> <span class="mi">14399000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Tokyo'</span><span class="p">,</span> <span class="s">'Japan'</span><span class="p">,</span> <span class="mi">13515271</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Moscow'</span><span class="p">,</span> <span class="s">'Russia'</span><span class="p">,</span> <span class="mi">13200000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Guangzhou'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">13081000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Shenzhen'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">12528300</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Mumbai'</span><span class="p">,</span> <span class="s">'India'</span><span class="p">,</span> <span class="mi">12442373</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'São Paulo'</span><span class="p">,</span> <span class="s">'Brazil'</span><span class="p">,</span> <span class="mi">12038000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Kinshasa'</span><span class="p">,</span> <span class="s">'Democratic Republic of the Congo'</span><span class="p">,</span> <span class="mi">11462000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Tianjin'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">11249000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Lahore'</span><span class="p">,</span> <span class="s">'Pakistan'</span><span class="p">,</span> <span class="mi">11126000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Delhi'</span><span class="p">,</span> <span class="s">'India'</span><span class="p">,</span> <span class="mi">11034555</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Jakarta'</span><span class="p">,</span> <span class="s">'Indonesia'</span><span class="p">,</span> <span class="mi">10624000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Dongguan'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">10615000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Seoul'</span><span class="p">,</span> <span class="s">'South Korea'</span><span class="p">,</span> <span class="mi">9806000</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Foshan'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="mi">9279000</span><span class="p">)]</span>

<span class="n">dict_by_country</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">cities</span><span class="p">:</span>
    <span class="n">city_name</span><span class="p">,</span> <span class="n">country_name</span> <span class="o">=</span> <span class="n">city</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dict_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">city_name</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="n">dict_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">city_name</span><span class="p">]</span>
</code></pre></div></div>

<p>보시다시피 <code class="highlighter-rouge">KeyError</code>를 반드시 <code class="highlighter-rouge">except</code>해 줘야 합니다. 딕셔너리를 처음 선언하면 빈(empty) 상태이므로 키로 접근(access)하면 필연적으로 <code class="highlighter-rouge">KeyError</code>를 일으킵니다. 어쩔 수 없이 추가한 <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">except</code> 부분이 사실 참 눈에 거슬립니다. 필요한 이유는 알겠는데 정녕 저렇게 지저분하게 코드를 만들어야만 할까요?</p>

<p>이럴 때 사용할 수 있는 게 <code class="highlighter-rouge">defaultdict</code>입니다. <code class="highlighter-rouge">defaultdict</code>는 <code class="highlighter-rouge">collections</code> 라이브러리에 탑재되어 있습니다. <code class="highlighter-rouge">defaultdict</code>는 딕셔너리(dict)와 거의 똑같은 용법으로 사용할 수 있습니다. 다른 점은 나온 적 없는 키로 접근을 해도 <code class="highlighter-rouge">KeyError</code>를 일으키지 않고 무언가 초기 값(default value)를 내뱉는다는 데 있습니다. 그래서 이름이 <code class="highlighter-rouge">defaultdict</code>인가 보지요.</p>

<p>단, <code class="highlighter-rouge">defaultdict</code>를 선언할 때 <code class="highlighter-rouge">default_factory</code>라는 인자를 입력해야 하는데 일반적으로 Python의 기본 자료형을 씁니다. <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code> 같은 자료형부터 <code class="highlighter-rouge">list</code>, <code class="highlighter-rouge">set</code> 같은 자료구조도 가능합니다. <code class="highlighter-rouge">defaultdict</code>를 이용해 위의 코드를 다시 구현해 보시죠. 훨씬 깔끔한 작성이 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">dict_by_country</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">cities</span><span class="p">:</span>
    <span class="n">city_name</span><span class="p">,</span> <span class="n">country_name</span> <span class="o">=</span> <span class="n">city</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dict_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">city_name</span><span class="p">)</span>
</code></pre></div></div>

<p>거추장스러운 <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">catch</code>를 사용하지 않아도 되어 훨씬 좋지요? <code class="highlighter-rouge">dict_by_country[country_name].append(city_name)</code>을 한번 살펴 봅시다. <code class="highlighter-rouge">defaultdict</code>인 <code class="highlighter-rouge">dict_by_country</code>는 처음 나오는(본 적 없는) 키의 접근을 필연적으로 겪을 것인데 이때 <code class="highlighter-rouge">defaultdict</code>는 빈 리스트(empty <code class="highlighter-rouge">list</code>)를 반환합니다. 여기에 <code class="highlighter-rouge">append()</code> 처리가 이어지는 것이고요.</p>

<p>또 다른 사례를 한번 보실까요? 위에서 본 인구 순위 데이터를 이용해 순위 목록 속 각 국가가 가지는 인구의 합이 어떻게 되는지 알아봅시다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># using dict</span>
<span class="n">pop_by_country</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">cities</span><span class="p">:</span>
    <span class="n">country_name</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">city</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pop_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pop</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="n">pop_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop</span>

<span class="c"># using defaultdict</span>
<span class="n">pop_by_country</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">cities</span><span class="p">:</span>
    <span class="n">country_name</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">city</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">pop_by_country</span><span class="p">[</span><span class="n">country_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pop</span>
</code></pre></div></div>
<p>역시, <code class="highlighter-rouge">defaultdict</code>를 사용한 코드가 훨씬 읽기 좋다는 점을 알 수 있겠죠? 어떤가요? <code class="highlighter-rouge">dict</code> 대신 무조건 <code class="highlighter-rouge">defaultdict</code>를 사용할 필요는 없습니다. 그렇지만 위에서 살표본 예시들과 비슷한 상황에서는 <code class="highlighter-rouge">dict</code> 대신 <code class="highlighter-rouge">defaultdict</code>를 사용해 훨씬 읽기 좋고 관리하기 편한 코드를 작성할 수 있습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Pandas의 DataFrame 사용 중 SettingWithCopyWarning 발생할 때</title>
	  <link>//pandas-dataframe-settingwithcopywarning</link>
	  <author></author>
	  <pubDate>2019-07-09T08:00:00+09:00</pubDate>
	  <guid>//pandas-dataframe-settingwithcopywarning</guid>
	  <description><![CDATA[
	     <p>Python의 Pandas 라이브러리 사용자에게 DataFrame은 매우 중요한 도구입니다. R 언어의 데이터프레임을 대체하기 위해 고안된 Pandas DataFrame은 이제 R을 훨씬 뛰어넘어 데이터 처리의 절대적인 도구로서 위치를 점하고 있습니다.</p>

<p>Pandas DataFrame은 R 언어의 관련 기능을 상당수를 대체한 것에 모자라, 커서(cursor)로 처리하는 고수준(high-level) 프로그래밍 언어에서의 SQL 처리와 PL/SQL을 대체했습니다. 최근에는 Excel 등 스프레드시트(spreadsheet)의 기능도 대체하기 시작했고요.</p>

<p>원천 자료에 일차 데이터 처리가 반영된 이차 자료를 만들고 계속적 처리를 통해 n차 자료를 만들면서, 여러 n차 자료들을 분석과 추론으로 엮어 통찰(insight)를 얻어 내는 일은 데이터 분석의 기본이자 핵심입니다.</p>

<p>이 과정에서 DataFrame을 SELECT하고(row 관점의 filtering) PROJECT하여(column 관점의 filtering) 가공된 파생 DataFrame을 만들고, 여기에 다시 연산을 가해 분석적 통찰이 반영된 DataFrame을 만듭니다. 이와 같은 과정이 여러 번 반복되지요.</p>

<p>파생된 DataFrame을 분석해 발견한 데이터를 그 DataFrame에 열(column)로서 추가하는 일 또한 자주 사용될 것입니다. 그런데 DataFrame에 열을 추가하는 과정에서 Pandas 자체에서 발생시키는 경고(warning) 메시지를 몇 번 본 적 있을 것이입니다. SettingWithCopyWarning라는 이름의 경고 말이죠.</p>

<p>이 경고가 어떤 상황에 발생하는지 원리를 이해하여 런타임 전에 미리 예방할 수 있다면 번거로움이 줄어들 것입니다. 어떤 경우에 발생할까요? 원천이 되는 DataFrame의 일부로 구성된 파생 DataFrame에 변경을 가하는 경우 발생합니다. 쉬운 예제로 SettingWithCopyWarning의 발생을 재현할 수 있지요. 아래처럼요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span><span class="p">,</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="c"># [-9 -3  5  9  7 -6 -2  4 -5  6]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">'NUM'</span><span class="p">])</span>
<span class="c">#    NUM</span>
<span class="c"># 0   -9</span>
<span class="c"># 1   -3</span>
<span class="c"># 2    5</span>
<span class="c"># 3    9</span>
<span class="c"># 4    7</span>
<span class="c"># 5   -6</span>
<span class="c"># 6   -2</span>
<span class="c"># 7    4</span>
<span class="c"># 8   -5</span>
<span class="c"># 9    6</span>

<span class="n">df_positive</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">NUM</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">df_positive</span><span class="p">[</span><span class="s">'SQUARED'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_positive</span><span class="o">.</span><span class="n">NUM</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c"># SettingWithCopyWarning: </span>
<span class="c"># A value is trying to be set on a copy of a slice from a DataFrame.</span>
<span class="c"># Try using .loc[row_indexer,col_indexer] = value instead</span>
<span class="c"># </span>
<span class="c"># See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy</span>

<span class="k">print</span><span class="p">(</span><span class="n">df_positive</span><span class="p">)</span>
<span class="c">#    NUM  SQUARED</span>
<span class="c"># 2    5       25</span>
<span class="c"># 3    9       81</span>
<span class="c"># 4    7       49</span>
<span class="c"># 7    4       16</span>
<span class="c"># 9    6       36</span>
</code></pre></div></div>

<p>왜 이런 경고를 발생시킬까요? 번거롭기만 하고 별 이득은 없는 validation인 것 같은데 말이지요. 그렇지 않습니다. 매우 중요한 역할을 하는 경고입니다. Pandas DataFrame은 연쇄적인(chained) 연산과 처리를 허용합니다. SQL에서 테이블을 SELECT한 결과가 다시 테이블이 되어 다시 SELECT할 수 있는 것과 유사하게, DataFrame도 그런 성질을 띱니다. 이것이 관계형 데이터베이스의 closure에 해당하는 개념인 것이죠.</p>

<p>한편 DataFrame도 자료구조(data structure)인 셈이므로 이를  표현하기 위해 메모리를 점유합니다. 등장하는 모든 DataFrame에 메모리를 할당하려 들면 금방 바닥을 보이게 되겠지요. Pandas에서는 원천 DataFrame을 생성할 때만 메모리를 할당하고 이로부터 파생되는 DataFrame은 원천 DataFrame을 이미 적재된 메모리에 접근케 하며 이로 인해 메모리를 절약합니다. 원천 DataFrame의 부분집합(subset)에 view를 형성한다 보면 됩니다.</p>

<p>파생된 DataFrame에 열(columns)을 하나 추가하면 어떻게 될까요? 한 DataFrame의 부분집합으로 이뤄진 view에 변경을 가하는 셈이지요. 원천 DataFrame에도 그 열을 붙여 줘야 할까요? 아니면 파생 DataFrame에만 붙이면 될까요? 원천 DataFrame에 그 열을 붙인다면, 파생 DataFrame에서 등장하지 않은 행(row)들에도 무언가를 붙여야 할까요, 말아야 할까요? 붙인다면 None으로 채워야 할까요?</p>

<p>이런 복잡한 질문에는 정답이 없습니다. 실제 개발하는 사람의 의도에 따라 원하는 바가 다를 수 밖에 없습니다. Pandas에서는 파생 DataFrame에 수정을 가하는 것을 권장하지 않습니다.(그래서 경고를 띄우는 것이죠.) 대신 Pandas는 copy() 메서드를 통해 파생 DataFrame에 독립적인 메모리를 부여한 뒤 여기에 수정을 가하도록 유도하지요. view를  실질화(materialization)시키는 것이죠.</p>

<p>요컨대 SettingWithCopyWarning의 발생을 예방하기 위한 가장 쉬운 방법은 파생 DataFrame에 copy() 메서드를 실행해, 원천 DataFrame과 별도인 메모리 공간을 파생 DataFrame에 부여하는 것입니다. 원천과 파생이 완전히 갈라서는 것이지요. 위에서 던졌던 복잡하고 귀찮은 질문들은 대답할 필요가 없게 되는 것이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># with SettingWithCopyWarning</span>
<span class="n">df_positive</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">NUM</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">df_positive</span><span class="p">[</span><span class="s">'SQUARED'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_positive</span><span class="o">.</span><span class="n">NUM</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c"># SettingWithCopyWarning: </span>
<span class="c"># A value is trying to be set on a copy of a slice from a DataFrame.</span>
<span class="c"># Try using .loc[row_indexer,col_indexer] = value instead</span>
<span class="c"># </span>
<span class="c"># See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy</span>

<span class="c"># without SettingWithCopyWarning</span>
<span class="n">df_positive</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">NUM</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">df_positive</span><span class="p">[</span><span class="s">'SQUARED'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_positive</span><span class="o">.</span><span class="n">NUM</span> <span class="o">**</span> <span class="mi">2</span>

<span class="k">print</span><span class="p">(</span><span class="n">df_positive</span><span class="p">)</span>
<span class="c">#    NUM  SQUARED</span>
<span class="c"># 2    5       25</span>
<span class="c"># 3    9       81</span>
<span class="c"># 4    7       49</span>
<span class="c"># 7    4       16</span>
<span class="c"># 9    6       36</span>
</code></pre></div></div>

<p>물론 이 경우 파생 DataFrame에 메모리가 부여되므로 사용 가능한 총 메모리는 줄어들게 됩니다. 이를 잘 감안해 사용해야 합니다. copy()를 막 하다 보면 어느순간 메모리가 바닥나는 상황도 생길 수 있으니까요.</p>

<p>어쨌든 SettingWithCopyWarning은 의도치 않은 구현을 경고하는 중요한 장치입니다. 경고를 무시하고 개발해도 원하는 처리가 당장 된다고 해서 SettingWithCopyWarning을 무시하는 것보다는, SettingWithCopyWarning가 발생하지 않는 방식으로 개발하는 습관이 중요합니다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Python 별표(*) 문법(asterisk/star syntax), *args와 **kwargs</title>
	  <link>//python-star-asterisk-args-kwargs</link>
	  <author></author>
	  <pubDate>2019-07-06T07:00:00+09:00</pubDate>
	  <guid>//python-star-asterisk-args-kwargs</guid>
	  <description><![CDATA[
	     <p>Python에는 우리나라에서 흔히 별표라 부르는 asterisk(<code class="highlighter-rouge">*</code>)를 활용한 특이한 문법(syntax)가 있습니다. <code class="highlighter-rouge">*args</code>, <code class="highlighter-rouge">**kwargs</code>라고 해도 통합니다. C나 C++이 아닌 Python에서 <code class="highlighter-rouge">*</code>와 <code class="highlighter-rouge">**</code>를 문두에 사용하는 문법이 있다니 어색하긴 하지만, 용도를 제대로 알면 유용히 쓸 수 있습니다.</p>

<h3 id="메서드-정의-시-파라미터parameter로-쓰일-때">메서드 정의 시 파라미터(parameter)로 쓰일 때</h3>

<p>메서드 정의 시 파라미터(parameter)로 <code class="highlighter-rouge">*args</code>가 사용되면 그 메서드 내에서 <code class="highlighter-rouge">args</code>는 메서드 호출 시 투입된 아규먼트(argument)의 튜플(tuple)이 됩니다. 파라미터의 개수가 고정적이지 않은 메서드의 정의 시 사용됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">args_as_parameter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="n">args_as_parameter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'three'</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="c"># &lt;class 'tuple'&gt;</span>
<span class="c"># (1, '2', 'three', 4.0)</span>
</code></pre></div></div>

<p>메서드 정의 시 파라미터로 <code class="highlighter-rouge">**kwargs</code>가 사용되면 그 메서드 내에서 <code class="highlighter-rouge">kwargs</code>는 메서드 호출 시 투입된 아규먼트의 딕셔너리(dict)가 됩니다. 당연히 아규먼트는 key-value 형태여야 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kwargs_as_parameter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">kwargs_as_parameter</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s">'2'</span><span class="p">,</span> <span class="n">third</span><span class="o">=</span><span class="s">'three'</span><span class="p">,</span> <span class="n">fourth</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>
<span class="c"># &lt;class 'dict'&gt;</span>
<span class="c"># {'first': 1, 'second': '2', 'third': 'three', 'fourth': 4.0}</span>
</code></pre></div></div>

<h3 id="메서드-호출-시-아규먼트argument로-쓰일-때">메서드 호출 시 아규먼트(argument)로 쓰일 때</h3>

<p>메서드 호출 시 아규먼트로 <code class="highlighter-rouge">*args</code>를 투입한다 가정할 때, <code class="highlighter-rouge">args</code>는 튜플(또는 리스트, list 등)이어야 합니다. 따라서 앞서 정의한 메서드 <code class="highlighter-rouge">args_as_parameter()</code>를 다음과 같이 호출할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'three'</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="n">args_as_parameter</span><span class="p">(</span><span class="o">*</span><span class="n">input_tuple</span><span class="p">)</span>
</code></pre></div></div>

<p>메서드 호출 시 아규먼트로 <code class="highlighter-rouge">**kwargs</code>를 투입한다 가정할 때, <code class="highlighter-rouge">kwargs</code>는 딕셔너리이어야 합니다. 따라서 앞서 정의한 메서드 <code class="highlighter-rouge">kwargs_as_parameter()</code>를 다음과 같이 호출할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">'first'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'second'</span><span class="p">:</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'third'</span><span class="p">:</span> <span class="s">'three'</span><span class="p">,</span> <span class="s">'fourth'</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">}</span>
<span class="n">kwargs_as_parameter</span><span class="p">(</span><span class="o">**</span><span class="n">input_dict</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="args와-kwargs를-메서드-호출-아규먼트로-유용히-쓸-수-있는-용례"><code class="highlighter-rouge">*args</code>와 <code class="highlighter-rouge">**kwargs</code>를 메서드 호출 아규먼트로 유용히 쓸 수 있는 용례</h3>

<p><code class="highlighter-rouge">zip()</code>은 리스트들을 투입받아 묶어 주는 역할을 합니다. 이 기능을 이용해서 m * n 자료를 n * m 자료로 변환하는 데 쓰이기도 하지요. 행렬의 transpose 격입니다. m * n 자료를 <code class="highlighter-rouge">zip()</code>에 투입하려면 그 속에 들어 있는 길이 n의 리스트를 m번 투입해야 하겠지요. 한두 개라면 별일 아니지만 m이 커진다면 가독성과 생산성, 확정성이 매우 떨어지게 됩니다. 이때 <code class="highlighter-rouge">*args</code>를 활용할 수 있습니다. 아래처럼 말이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">two_col_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">))</span>
<span class="n">four_col_tuple1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">two_col_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">two_col_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c"># long way</span>
<span class="k">print</span><span class="p">(</span><span class="n">four_col_tuple1</span><span class="p">)</span>
<span class="c"># ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))</span>
<span class="n">four_col_tuple2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">two_col_tuple</span><span class="p">))</span> <span class="c"># short way</span>
<span class="k">print</span><span class="p">(</span><span class="n">four_col_tuple2</span><span class="p">)</span>
<span class="c"># ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cx_Oracle</code>의 <code class="highlighter-rouge">connect()</code>는 데이터베이스의 접속 정보(URL, 포트, 서비스명, ID, PW 등을 아규먼트로 받습니다. 이를 모두 <code class="highlighter-rouge">connect()</code> 메서드에 투입하려면 헷갈려 실수하기 쉽습니다. 물론 사용에 숙달되면 일도 아닐 정도로 쉽겠지만 ‘나만 잘 짜고 잘 읽고 잘 고치는 코드’가 능사는 아니지요. 이 경우 아규먼트를 딕셔너리로 정의한 후 그것을 <code class="highlighter-rouge">**kwargs</code> 형태로 <code class="highlighter-rouge">connect()</code> 메서드에 투입하는 방법이 있습니다. 향후 데이터베이스 접속 정보가 바뀌어 수정해야 할 때 딕셔너리 속 요소들을 쉽게 읽어 바꾸면 되니 관리하기 좋겠지요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cx_Oracle</span>
<span class="c"># express way</span>
<span class="n">dsn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">makedsn</span><span class="p">(</span><span class="s">'localhost'</span><span class="p">,</span> <span class="mi">1521</span><span class="p">,</span> <span class="s">'orcl'</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">'sys'</span><span class="p">,</span> <span class="s">'orange'</span><span class="p">,</span> <span class="n">dsn</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">cx_Oracle</span><span class="o">.</span><span class="n">SYSDBA</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c"># tidy and readable way</span>
<span class="n">conn_conf</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">'user'</span><span class="p">:</span> <span class="s">'sys'</span><span class="p">,</span>
	<span class="s">'password'</span><span class="p">:</span> <span class="s">'orange'</span><span class="p">,</span>
	<span class="s">'dsn'</span><span class="p">:</span> <span class="n">dsn</span><span class="p">,</span>
	<span class="s">'mode'</span><span class="p">:</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">SYSDBA</span>
<span class="p">}</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="o">**</span><span class="n">conn_conf</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="참고자료">참고자료</h3>
<p>https://www.geeksforgeeks.org/args-kwargs-python/</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 정규표현식(regular expression) 그룹 이름 붙이기(named group)</title>
	  <link>//python-re-named-group</link>
	  <author></author>
	  <pubDate>2019-05-02T10:35:00+09:00</pubDate>
	  <guid>//python-re-named-group</guid>
	  <description><![CDATA[
	     <p>지금의 Python은 데이터 과학(data science)의 주류 언어로 각광받으면서, 프로그래밍 언어로서 황혼기를 누리고 있습니다. 데이터 과학의 러브콜을 받기 전 Python이 대중화가 될 수 있었던 이유는 강력한 문자열 처리에 있습니다. 사실 데이터 과학 분야에서도 Python의 문자열 처리 기능이 매우 유용하게 사용되지요. Tesorflow나 PyTorch 등 기계학습(machine learning) 및 인공지능(AI)라이브러리 또한 Python의 문자열 처리 기능 덕분에 더 빛을 발하지요.</p>

<p>Python에서도 문자열 처리 기능으로서 정규표현식(regular expression, regex)이 매우 유용히 사용됩니다. 사실 정규표현식은 Python만의 개념이 아니지요. 정규표현식 개념의 등장은 무려 1950년대로 거슬러 올라 갑니다. Python의 문자열 처리 기능의 강력함을 정규표현식만으로 설명할 수는 없는 노릇이지요. Python이 제공하는 특유의 문자열 처리 도구들과 특화된 라이브러리들과 정규표현식이 어우려져 사용될 때 비로소 막대한 시너지가 생깁니다.</p>

<p><code class="highlighter-rouge">startswith()</code>, <code class="highlighter-rouge">endswith()</code> 같은 기본 제공 모듈, <code class="highlighter-rouge">in</code>과 같은 키워드, <code class="highlighter-rouge">[:3]</code>, <code class="highlighter-rouge">[-5:]</code>와 같은 슬라이싱(slicing) 기능을 잘 활용하는 것도 물론 중요하겠지만, Python이 제공하는 정규표현식 라이브러리인 re를 능수능란히 다루는 능력 또한 중요합니다. 물론 정규표현식에 대한 기본 지식 또한 중요하겠지요.</p>

<p>여기에서는 Python의 re 라이브러리를 사용할 때 정규표현식 속 그룹에 이름을 붙여 이용하는 방법(named group)과 이름 붙여진 그룹에 직접 접근하는 방법을 살펴 보겠습니다. 이름 붙여진 그룹이라 함은, 별다른 뜻은 아니고, 정규표현식 속 일부가 되는 특정 패턴에 명시적인 이름을 붙였을 때를 말합니다.</p>

<p>가장 기본이 되는, 정규표현식 속 그룹에 이름을 붙이는 방법은 아래와 같습니다. <code class="highlighter-rouge">(?P&lt;NAME&gt;...)</code>은 괄호 속 패턴 부분에 NAME이라고 이름을 붙이는 방법입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">re</span>

<span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking'</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Michael speaking.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="c"># &lt;re.Match object; span=(7, 24), match=' Michael speaking'&gt;</span>
</code></pre></div></div>

<p>위 코드에서는 붙인 이름으로 <code class="highlighter-rouge">search()</code>로 찾은 패턴에 직접 접근하지 않습니다. 아래 코드처럼 하면 붙인 이름을 통해 패턴에 직접 접근할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># Michael</span>
</code></pre></div></div>

<p>하나의 정규표현식에 둘 이상의 그룹을 잡고 각각 다른 이름을 붙일 수 있습니다. 이처럼 그룹 수가 많아지면 <code class="highlighter-rouge">group(...)</code>을 여러번 쓰는 것보다, 이름과 패턴의 쌍들로 만들어진 딕셔너리(dictionary)를 <code class="highlighter-rouge">groupdict()</code>로 받아 와 쓰는 게 편리합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME1&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+and</span><span class="err">\</span><span class="s">s+(?P&lt;NAME2&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking'</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is John and Jane speaking.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">groupdict</span><span class="p">())</span>
<span class="c"># {'NAME1': 'John', 'NAME2': 'Jane'}</span>
</code></pre></div></div>

<p>한편 정규표현식에 이미 등장해 이름 붙여 놓은 그룹을 다시 참조해 같은 식에 재활용하는 방법도 있습니다. 이를 named group backreference라고 부릅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'</span><span class="err">\</span><span class="s">s+(?P&lt;NAME&gt;</span><span class="err">\</span><span class="s">w+)</span><span class="err">\</span><span class="s">s+speaking</span><span class="err">\</span><span class="s">.</span><span class="err">\</span><span class="s">s+(?P=NAME)</span><span class="err">\</span><span class="s">s+is online</span><span class="err">\</span><span class="s">.'</span><span class="p">)</span>

<span class="n">result_a</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Michael speaking. Michael is online.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result_a</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># Michael</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result_a</span><span class="p">))</span>
<span class="c"># True</span>

<span class="n">result_b</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'This is Thomas speaking. Paul is online.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result_b</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'NAME'</span><span class="p">))</span>
<span class="c"># AttributeError: 'NoneType' object has no attribute 'group'</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result_b</span><span class="p">))</span>
<span class="c"># False</span>
</code></pre></div></div>

<p>위 코드를 보면, <code class="highlighter-rouge">result_a</code>에서는 정규표현식의 앞부분에서 찾은 패턴 Michael이 뒤에 다시 등장하여 정상적으로 탐색(search)이 된 것을 알 수 있습니다. 반면 <code class="highlighter-rouge">result_b</code>에서는 앞부분 패턴은 Thomas지만 뒷부분 패턴은 Paul입니다. 앞뒤 패턴이 달라 탐색이 실패한 것이지요. 참고로, re 라이브러리의 정규표현식 결과를 <code class="highlighter-rouge">bool()</code>로 캐스팅(casting)하면, 패턴이 찾아진 경우 True, 아닌 경우 False를 반환합니다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
